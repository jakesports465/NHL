<!doctype html>
<html lang="en">
<head>
<link rel="icon" type="image/png" sizes="32x32" href="logo.png">
<link rel="icon" type="image/png" sizes="192x192" href="logo.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>NHL Puck'Em</title>
<style>
  .tab {
  /* Shared styles for all tab buttons and links */
  padding: 0.5em 1em;
  border: none;
  background: none;
  font: inherit;
  cursor: pointer;
  text-decoration: none; /* ‚úÖ Removes underline from links */
  color: inherit;         /* Optional: makes link text match surrounding text */
}

  :root{ --bg:#0b0d10; --card:#12161b; --muted:#8ea0b3; --text:#e8eef4; --br:#1b232d }

/* === Unified scrollbars (WebKit + Firefox) === */
*{
  scrollbar-width: thin;                 /* Firefox */
  scrollbar-color: #334658 transparent;  /* thumb | track */
}
*::-webkit-scrollbar{
  width:10px; height:10px;               /* Chrome/Edge/Safari */
}
*::-webkit-scrollbar-track{
  background: transparent;
}
*::-webkit-scrollbar-thumb{
  background:#334658;
  border-radius:999px;
  border:2px solid transparent;          /* creates the inset gap */
  background-clip: padding-box;
}



  
  /* Base */
  html,body{
    margin:0;background:var(--bg);color:var(--text);
    font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    -webkit-text-size-adjust:100%;
    -webkit-tap-highlight-color:transparent;
  }
  *,*::before,*::after{box-sizing:border-box}
  :focus-visible{outline:2px solid #3c82f6; outline-offset:2px; border-radius:8px}

  /* Motion */
  @media (prefers-reduced-motion:no-preference){
    .animate-enter{transition:opacity .2s ease, transform .2s ease}
    .animate-enter[data-show="true"]{opacity:1; transform:none}
    .animate-enter[data-show="false"]{opacity:.98; transform:translateY(2px)}
  }

  /* Header + Tabs (mobile-first) */
  header{
    padding:12px 14px;
    padding-top:calc(12px + env(safe-area-inset-top));
    border-bottom:1px solid var(--br);
    background:#0f1318; position:sticky; top:0; z-index:20;
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  }
  h1{margin:0;font-size:18px}
  .sub{color:var(--muted);font-size:13px;margin-left:6px}
  .pill{border:1px dashed #364353;border-radius:999px;padding:4px 10px;font-size:12px;white-space:nowrap}

  nav.tabs{
    display:flex; gap:8px; padding:10px 12px;
    background:#0f1318;border-bottom:1px solid var(--br);
    position:sticky; top:56px; z-index:19; overflow-x:auto; scrollbar-width:none;
    scroll-snap-type:x mandatory;
  }
  nav.tabs::-webkit-scrollbar{display:none}
  .tab{
    padding:10px 12px;border:1px solid #243241;border-radius:10px;
    background:#111822;color:var(--text);cursor:pointer;font-size:13px;flex:0 0 auto;
    scroll-snap-align:start;
  }
  .tab[aria-selected="true"]{background:#162231;border-color:#31506a;font-weight:700}

  /* Sections / layout */
  .section{display:none}
  .section.active{display:block}
  main{max-width:1160px;margin:0 auto;padding:14px 14px 64px}
  .card{background:var(--card);border:1px solid var(--br);border-radius:14px;padding:12px}
  .panel{background:#0f1318;border:1px solid #1c2430;border-radius:12px;padding:10px}
  .sep{height:1px;background:var(--br);margin:12px 0}
  .small{font-size:12px;color:var(--muted)}

  /* Buttons / fields */
  .btn{
    background:#14202b;border:1px solid #243241;color:var(--text);
    padding:12px 14px;border-radius:10px;cursor:pointer;font-size:14px;line-height:1;min-height:44px;
    touch-action:manipulation;
  }
  .btn.small{padding:10px 12px;font-size:13px;min-height:40px}
  .btn[disabled]{opacity:.6;cursor:not-allowed}
  .field{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type="text"], input[type="email"], input[type="password"]{
    flex:1;background:#0b1117;border:1px solid #1b2633;border-radius:8px;color:var(--text);
    padding:10px;min-height:40px;font-size:16px;
  }
  ::placeholder{color:#8ea0b3;opacity:.9}

  /* Games grid */
  .gamesGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
  .gameCard{background:#11171e;border:1px solid #1f2a36;border-radius:14px;overflow:hidden}
  .band{height:6px}
  .gameBody{padding:12px}
  .teamsRow{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .team{display:flex;align-items:center;gap:8px;min-width:0}
  .team img{width:22px;height:22px;border-radius:6px;border:1px solid #1e2732;background:#0f1318}
  .team .name{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .scoreTag{display:inline-block;margin-left:6px;padding:2px 6px;border:1px solid #26313c;border-radius:6px;font-weight:700;min-width:24px;text-align:center}
  .lockRow{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;align-items:center}
  .lockRow .btn{flex:1 1 140px}
  .pickedTag{
    display:inline-flex;align-items:center;gap:6px;border:1px solid #2e5e3f;background:#0e1a14;color:#9be7b0;
    border-radius:999px;padding:6px 10px;font-size:12px
  }

  /* Top detail grid */
  .topGrid{display:grid;grid-template-columns:1fr 220px 220px;gap:12px;align-items:start}
  @media(max-width:980px){.topGrid{grid-template-columns:1fr}}
  .teamline{
    display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:12px;background:#0f1318;border:1px solid #1c2430
  }
  .teamline img{width:44px;height:44px;border-radius:8px;border:1px solid #1e2732;background:#0d1218}
  .statusBox,.scoreBox{background:#0f1318;border:1px solid #1c2430;border-radius:12px;padding:12px}
  .scoreBox{text-align:center}
  .scoreBox .num{font-size:34px;font-weight:900}

  /* Logs */
  .playsWrap{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:900px){.playsWrap{grid-template-columns:1fr}}
  .plist{max-height:38vh;overflow:auto;background:#0f1318;border-radius:10px;padding:8px;border:1px solid #1b232d}
  .play{display:grid;grid-template-columns:auto 1fr;gap:10px;padding:9px;border:1px solid #1c2430;border-radius:10px;background:#0f1318;margin-bottom:8px}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.goal{background:#20d07a}.dot.other{background:#6aa0ff}
  .when{color:var(--muted);font-size:12px}

  /* Leaderboards */
  .lbHeaderRow{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;gap:10px;flex-wrap:wrap}
  .lbRow{display:grid;grid-template-columns:auto 1fr auto auto;gap:10px;align-items:center;padding:8px;border-radius:10px;border:1px solid #1c2430;background:#0f1318;margin-bottom:8px}
  .lbPos{width:42px;text-align:center;font-weight:900;border:1px solid #26313c;border-radius:8px;padding:4px 0;opacity:.95}
  .lbTeam{display:flex;gap:10px;align-items:center;min-width:0}
  .lbTeam img{width:20px;height:20px;border-radius:4px;border:1px solid #1c2330;background:#0d1218;flex:0 0 auto}
  .lbName{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .lbPts{font-weight:800}

  .badge{display:inline-block;background:#101722;border:1px solid #253548;border-radius:8px;padding:2px 6px;margin-left:6px}

  /* Rules */
  .rules{display:grid;gap:8px}
  .rules .r{display:flex;justify-content:space-between;gap:12px;padding:8px;border:1px solid #1c2430;background:#0f1318;border-radius:10px}

  /* Badges */
  .badgeGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px}
  .bTile{display:flex;gap:10px;align-items:center;background:#0f1318;border:1px solid #1c2430;border-radius:12px;padding:10px;opacity:.55;filter:grayscale(100%)}
  .bIcon{width:40px;height:40px;border-radius:10px;border:1px solid #223040;background:#0d131a;display:flex;align-items:center;justify-content:center;font-weight:900}
  .bMeta{display:flex;flex-direction:column;gap:2px}
  .bMeta .nm{font-weight:700}
  .bMeta .lk{font-size:12px;color:#97a7b9}
  .bTile.unlocked{opacity:1;filter:none;border-color:#335a7a}

  /* Larger viewports polish */
  @media (min-width:700px){
    main{padding:16px 18px 70px}
    .gamesGrid{grid-template-columns:repeat(auto-fill,minmax(260px,1fr))}
    .scoreBox .num{font-size:38px}
    .teamline img{width:44px;height:44px}
  }

  /* Phone tweaks */
  @media (max-width:720px){
    h1{font-size:16px}
    .sub{display:block;margin:2px 0 0 0}
    .pill{margin-left:0}
    .small{font-size:12px}
    .lbRow{grid-template-columns:auto 1fr auto; row-gap:6px}
    .lbRow .small{grid-column:1 / -1; justify-self:start}
    header{padding-top:calc(12px + env(safe-area-inset-top))}
    nav.tabs{top:52px}
  }

  /* Two-column areas collapse cleanly on mobile */
  @media (max-width:920px){
    .twoCol{display:grid;grid-template-columns:1fr;gap:12px}
  }

  /* Respect safe-area on bottom */
  body{padding-bottom:env(safe-area-inset-bottom)}

  /* Simple table styling for Fantasy Breakdown */
  .fTable{width:100%; border-collapse:collapse; font-size:13px}
  .fTable th,.fTable td{border:1px solid #1c2430; padding:6px 8px; text-align:right}
  .fTable th:first-child,.fTable td:first-child{text-align:left}
  .fTable tfoot td{font-weight:800}

  /* Auth bar */
  #authBox{background:#0f1318;border:1px solid var(--br);border-radius:12px;padding:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #authBox .btn.small{min-height:38px;padding:9px 12px}
  #forgotLink{color:var(--muted); text-decoration:none; padding:6px 4px}
  #forgotLink:hover{color:#cfe2f5; text-decoration:underline}
  #authBox input{min-width:180px}
  @media (max-width:700px){#authBox input{min-width:140px}}
</style>
</head>
<body>
<header>
  <img src="logo.png" alt="QuickPucks Logo" style="height:40px;">

  <h1>NHL Puck'Em <span class="sub">Every Monday‚ÜíSunday ¬∑ 5 picks</span></h1>
  <span id="picksLeft" class="pill">Sign in to play</span>
  <span class="small" style="margin-left:auto">Week: <b id="weekLabel">‚Äî</b></span>
  
  <div id="authBox" class="field" style="margin-left:auto;gap:6px;flex-wrap:wrap">
    <a class="btn small" href="signup.html">Sign up</a>
    <form id="loginPwForm" class="field" style="gap:6px">
      <input id="liEmail" type="email" placeholder="email@example.com" required>
      <input id="liPass"  type="password" placeholder="Password" required>
      <button class="btn small" type="submit">Log in</button>
      <a href="#" id="forgotLink" class="small" style="text-decoration:underline">Forgot?</a>
    </form>
    <div id="userBox" class="field" style="display:none;gap:6px">
      <span class="small" id="whoami">‚Äî</span>
      <input id="displayNameInput" type="text" placeholder="Display name" style="max-width:180px">
      <button id="saveDisplayName" class="btn small" type="button">Save</button>
      <button id="logoutBtn" class="btn small" type="button">Sign out</button>
    </div>
  </div>
</header>

<nav class="tabs" role="tablist" aria-label="Sections">
  <button class="tab" id="tab-nhl"   role="tab" aria-controls="sec-nhl"   aria-selected="true">NHL</button>
  <button class="tab" id="tab-mine"  role="tab" aria-controls="sec-mine"  aria-selected="false">Picks</button>
  <button class="tab" id="tab-lb"    role="tab" aria-controls="sec-lb"    aria-selected="false">Leaderboards</button>
  <button class="tab" id="tab-badges" role="tab" aria-controls="sec-badges" aria-selected="false">Badges</button>
  <button class="tab" id="tab-rules" role="tab" aria-controls="sec-rules" aria-selected="false">Scoring</button>
  <a class="tab" href="./chat.html" role="tab" aria-selected="false">Chat Locker Room</a>
  <a class="tab" href="./playbook.html" role="tab" aria-selected="false">FAQ and Rules</a>

</nav>

<!-- ===== NHL ===== -->
<section id="sec-nhl" class="section active" aria-labelledby="tab-nhl">
  <main>
    <section id="nhl-top" class="card animate-enter" data-show="false" style="display:none">
      <div class="small" id="nhl-liveHeader">‚Äî</div>
      <div class="topGrid" style="margin-top:8px">
        <div id="nhl-teamSide"></div>
        <div class="scoreBox">
          <div class="small" style="margin-bottom:4px">Fantasy Score</div>
          <div id="nhl-fscore" class="num">‚Äî</div>
          <div id="nhl-bonuses" class="small">‚Äî</div>
        </div>
        <div class="statusBox">
          <div class="small" style="margin-bottom:4px">Game Status</div>
          <div class="small">Clock: <b id="nhl-clock">‚Äî</b></div>
          <div class="small">Period: <b id="nhl-q">‚Äî</b></div>
          <div class="small">State: <b id="nhl-state">‚Äî</b></div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="lockRow">
        <button id="nhl-back" class="btn small">‚Üê Back to games</button>
        <button id="nhl-addPick" class="btn small">Add to my picks</button>
      </div>

      <div class="sep"></div>

      <!-- Fantasy Breakdown -->
      <section class="panel">
        <h3 style="margin:0 0 6px 0">Fantasy Breakdown</h3>
        <table class="fTable" id="nhl-breakdown">
          <thead>
            <tr><th>Stat</th><th>Total</th><th>Value</th><th>Fantasy Points</th></tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr><td colspan="3">Bonuses</td><td id="bd-bonuses">0.00</td></tr>
            <tr><td colspan="3">Total</td><td id="bd-total">0.00</td></tr>
          </tfoot>
        </table>
      </section>

      <div class="sep"></div>

      <!-- NEW: Plays (Scoring + Recent) -->
      <div class="playsWrap">
        <section class="panel">
          <h3 style="margin:0 0 6px 0">Scoring Plays</h3>
          <div id="nhl-scoreList" class="plist"><div class="small">No data yet.</div></div>
        </section>
        <section class="panel">
          <h3 style="margin:0 0 6px 0">Recent Plays</h3>
          <div id="nhl-recentList" class="plist"><div class="small">No data yet.</div></div>
        </section>
      </div>

      <div class="sep"></div>

      <section class="panel">
        <h3 style="margin:0 0 6px 0">Top Games ‚Äî Fantasy (Top Games)</h3>
        <div id="nhl-gameLB"></div>
      </section>
      <div class="sep"></div>
    </section>

    <section id="nhl-gridCard" class="card">
      <div class="small" id="nhl-note">Loading NHL week‚Ä¶</div>
      <div class="sep"></div>
      <div id="nhl-grid" class="gamesGrid"></div>
    </section>
  </main>
</section>

<!-- ===== MY PICKS ===== -->
<section id="sec-mine" class="section" aria-labelledby="tab-mine">
  <main class="card">
    <div class="lbHeaderRow">
      <h2 style="margin:0">Picks</h2>
      <span class="small">Week: <b id="mineWeekLabel">‚Äî</b></span>
    </div>
    <div class="sep"></div>
    <div class="twoCol" style="display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start">
      <section class="panel">
        <h3 style="margin:0 0 6px 0">My Picks <span id="myNHLTotal" class="badge">0.00</span></h3>
        <div id="myNHL"></div>
      </section>
      <section class="panel">
        <h3 style="margin:0 0 6px 0">Everyone‚Äôs Picks ‚Äî This Week</h3>
        <div id="allPicks"></div>
      </section>
    </div>
  </main>
</section>

<!-- ===== LEADERBOARD ===== -->
<section id="sec-lb" class="section" aria-labelledby="tab-lb">
  <main class="card">
    <div class="lbHeaderRow">
      <h2 style="margin:0">Leaderboards</h2>
    </div>
    <div class="small" id="lbWeekLabel" style="margin-bottom:8px">‚Äî</div>
    <div class="sep"></div>
    <div class="twoCol" style="display:grid;grid-template-columns:1fr 1fr;gap:16px">
      <section class="panel">
        <h3 style="margin:0 0 6px 0">This Week</h3>
        <div id="lbNHLWeek"></div>
      </section>
      <section class="panel">
        <h3 style="margin:0 0 6px 0">Season</h3>
        <div id="lbNHLSeason"></div>
      </section>
    </div>
  </main>
</section>

<!-- ===== BADGES ===== -->
<section id="sec-badges" class="section" aria-labelledby="tab-badges">
  <main class="card">
    <div class="lbHeaderRow">
      <h2 style="margin:0">Badges</h2>
      <span class="small">All badges are shown locked for now.</span>
    </div>
    <div class="sep"></div>
    <div class="badgeGrid" id="badgeGrid">
      <div class="bTile" data-badge="first_star"><div class="bIcon">ü•á</div><div class="bMeta"><span class="nm">First Star of the Week</span><span class="lk">Finish 1st place weekly.</span></div></div>
      <div class="bTile" data-badge="second_star"><div class="bIcon">ü•à</div><div class="bMeta"><span class="nm">Second Star</span><span class="lk">Finish 2nd place weekly.</span></div></div>
      <div class="bTile" data-badge="third_star"><div class="bIcon">ü•â</div><div class="bMeta"><span class="nm">Third Star</span><span class="lk">Finish 3rd place weekly.</span></div></div>
      <div class="bTile" data-badge="solid_ten"><div class="bIcon">üîü</div><div class="bMeta"><span class="nm">Solid Ten</span><span class="lk">Finish Top 10 weekly.</span></div></div>
      <div class="bTile" data-badge="consistent_contributor"><div class="bIcon">üéØ</div><div class="bMeta"><span class="nm">Consistent Contributor</span><span class="lk">Top 10 in half the season.</span></div></div>
      <div class="bTile" data-badge="heater"><div class="bIcon">üî•</div><div class="bMeta"><span class="nm">Heater</span><span class="lk">Top 5 three weeks in a row.</span></div></div>
      <div class="bTile" data-badge="iron_streak"><div class="bIcon">üèÖ</div><div class="bMeta"><span class="nm">Iron Streak</span><span class="lk">Top 10 five weeks in a row.</span></div></div>
      <div class="bTile" data-badge="hot_line"><div class="bIcon">‚ô®Ô∏è</div><div class="bMeta"><span class="nm">Hot Line</span><span class="lk">Top 5 five weeks in a row.</span></div></div>
      <div class="bTile" data-badge="cold_shift"><div class="bIcon">üßä</div><div class="bMeta"><span class="nm">Cold Shift</span><span class="lk">Miss Top 10 three straight.</span></div></div>
      <div class="bTile" data-badge="sniper"><div class="bIcon">üéØ</div><div class="bMeta"><span class="nm">Sniper</span><span class="lk">Pick the #1 scoring game of the week.</span></div></div>
      <div class="bTile" data-badge="hatty_picks"><div class="bIcon">üé©</div><div class="bMeta"><span class="nm">Hatty Picks</span><span class="lk">Three of your picks finish in the Top 5.</span></div></div>
      <div class="bTile" data-badge="clean_sweep"><div class="bIcon">üßπ</div><div class="bMeta"><span class="nm">Clean Sweep</span><span class="lk">All 5 picks finish in the Top 10.</span></div></div>
      <div class="bTile" data-badge="shutout"><div class="bIcon">üß±</div><div class="bMeta"><span class="nm">Shutout</span><span class="lk">All your picks below avg but still Top 10 weekly.</span></div></div>
      <div class="bTile" data-badge="overtime_winner"><div class="bIcon">‚è±Ô∏è</div><div class="bMeta"><span class="nm">Overtime Winner</span><span class="lk">Pick a game that goes to OT.</span></div></div>
      <div class="bTile" data-badge="presidents"><div class="bIcon">üèÜ</div><div class="bMeta"><span class="nm">President‚Äôs Trophy</span><span class="lk">End season 1st overall.</span></div></div>
      <div class="bTile" data-badge="playoff_bound"><div class="bIcon">üß≠</div><div class="bMeta"><span class="nm">Playoff Bound</span><span class="lk">End season Top 10.</span></div></div>
      <div class="bTile" data-badge="power_play"><div class="bIcon">‚ö°</div><div class="bMeta"><span class="nm">Power Play</span><span class="lk">Top 3 in four of five weeks.</span></div></div>
      <div class="bTile" data-badge="icebreaker"><div class="bIcon">üßä</div><div class="bMeta"><span class="nm">Icebreaker</span><span class="lk">Make your first pick ever.</span></div></div>
      <div class="bTile" data-badge="call_up"><div class="bIcon">üì£</div><div class="bMeta"><span class="nm">Call-Up</span><span class="lk">First time finishing Top 10.</span></div></div>
      <div class="bTile" data-badge="hot_prospect"><div class="bIcon">üìà</div><div class="bMeta"><span class="nm">Hot Prospect</span><span class="lk">First time finishing Top 3.</span></div></div>
    </div>
  </main>
</section>

<!-- ===== SCORING RULES ===== -->
<section id="sec-rules" class="section" aria-labelledby="tab-rules">
  <main class="card">
    <h2 style="margin:0 0 10px 0">Scoring Rules (Game-based)</h2>
    <div class="small" style="margin-bottom:8px">Close Game, Overtime, and Shootout will stack.</div>
    <div class="rules">
      <div class="r"><span>Goal</span><b>+4</b></div>
      <div class="r"><span>Power-Play Goal (bonus)</span><b>+1.5</b></div>
      <div class="r"><span>Short-Handed Goal (bonus)</span><b>+1</b></div>
      <div class="r"><span>Shot on Goal (combined, both teams)</span><b>+0.1</b></div>
      <div class="r"><span>Goalie Saves (combined)</span><b>+0.05</b></div>
      <div class="r"><span>Hits (combined)</span><b>+0.05</b></div>
      <div class="r"><span>Blocked Shots (combined)</span><b>+0.05</b></div>
      <div class="r"><span>Penalty Minutes (combined)</span><b>‚àí0.1 / min</b></div>
      <div class="r"><span>Close Game (final margin ‚â§ 1)</span><b>+4</b></div>
      <div class="r"><span>Overtime Played</span><b>+2</b></div>
      <div class="r"><span>Shootout Played</span><b>+2</b></div>
    </div>
  </main>
</section>

<!-- Supabase JS -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
/* ---------- CONFIG ---------- */
const SUPA_URL  = 'https://acmqdokxwnkkjmfgfyhh.supabase.co';
const SUPA_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFjbXFkb2t4d25ra2ptZmdmeWhoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzMDY4MDAsImV4cCI6MjA3Mzg4MjgwMH0.cHgUbNwXQvWZJnQNetxO5kr0kVPIR2XO9vVkIJZj_-w';
const supa = supabase.createClient(SUPA_URL, SUPA_ANON, {
  auth: { persistSession: true, detectSessionInUrl: true, flowType: 'pkce' }
});

/* ---------- PERF helpers (unchanged) ---------- */
const TZ='America/Chicago';
const MAX_PICKS=5;
const $ = id => document.getElementById(id);

const PERF_NS = `hf:${new Date().toISOString().slice(0,10)}`;
const L1 = new Map();
function k(ns){ return `${PERF_NS}:${ns}`; }
function getCache(ns){ const key=k(ns); if(L1.has(key)) return L1.get(key);
  try{ const raw=localStorage.getItem(key); if(!raw) return null;
    const obj=JSON.parse(raw); if(obj.exp && Date.now()>obj.exp){ localStorage.removeItem(key); return null; }
    L1.set(key,obj.val); return obj.val; }catch{ return null; }}
function setCache(ns,val,ttlMs){ const key=k(ns); L1.set(key,val);
  try{ localStorage.setItem(key, JSON.stringify({val,exp: ttlMs?Date.now()+ttlMs:null})); }catch{} }
function delCache(ns){ try{ localStorage.removeItem(k(ns)); }catch{} L1.delete(k(ns)); }

const INFLIGHT = new Map();
async function dedupFetch(url){
  if(INFLIGHT.has(url)) return INFLIGHT.get(url);
  const p = fetch(url,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(r.status); return r.json(); })
    .finally(()=>INFLIGHT.delete(url));
  INFLIGHT.set(url,p); return p;
}
async function safeJson(url,retries=2){
  for(let i=0;i<=retries;i++){
    try{ return await dedupFetch(url); }
    catch(e){ if(i===retries) throw e; await new Promise(r=>setTimeout(r,500*(i+1))); }
  }
}
async function pLimitAll(items, limit, worker){
  const out=new Array(items.length); let i=0, active=0;
  return await new Promise(resolve=>{
    const pump=()=>{
      while(active<limit && i<items.length){
        const idx=i++; active++;
        Promise.resolve(worker(items[idx],idx))
          .then(v=>{ out[idx]=v; })
          .catch(()=>{ out[idx]=undefined; })
          .finally(()=>{ active--; (i>=items.length && active===0)?resolve(out):pump(); });
      }
    };
    pump();
  });
}

/* ---------- Week logic (Mon 08:00 CT) ---------- */
function nowCT(){ return new Date(new Date().toLocaleString('en-US',{timeZone:TZ})); }
function addDaysCT(d,days){ const n=new Date(d.getTime()); n.setDate(n.getDate()+days); return new Date(n.toLocaleString('en-US',{timeZone:TZ})); }
function parts(d,opts){ const p=new Intl.DateTimeFormat('en-US',opts).formatToParts(d); const o={}; p.forEach(x=>o[x.type]=x.value); return o; }
function weekKey(){ const n=nowCT(); const wd=n.getDay(); const days=(wd-1+7)%7; const mon=addDaysCT(n,-days);
  const hour=Number(parts(n,{hour:'2-digit',hour12:false}).hour);
  const after8 = hour>=8 || days>0; const anchor = after8? mon : addDaysCT(mon,-7);
  const p=parts(anchor,{year:'numeric',month:'2-digit',day:'2-digit'}); return `${p.year}-${p.month}-${p.day}-Mon08CT`; }
function weekDates(){ const n=nowCT(); const wd=n.getDay(); const days=(wd-1+7)%7; const mon=addDaysCT(n,-days);
  const list=[]; for(let i=0;i<7;i++){ const d=addDaysCT(mon,i); const p=parts(d,{year:'numeric',month:'2-digit',day:'2-digit'}); list.push(`${p.year}-${p.month}-${p.day}`); }
  const pM=parts(mon,{month:'2-digit',day:'2-digit'}); const pS=parts(addDaysCT(mon,6),{month:'2-digit',day:'2-digit'});
  return {list,start:list[0],end:list[6],pretty:`${pM.month}/${pM.day} ‚Üí ${pS.month}/${pS.day}`}; }
const WEEK_KEY=weekKey(); const WEEK=weekDates();
$('weekLabel').textContent=WEEK.pretty; $('lbWeekLabel').textContent=`Week: ${WEEK.pretty}`; $('mineWeekLabel').textContent=WEEK.pretty;

/* ---------- ESPN helpers ---------- */
function cdnNHL(t){ if(!t) return null; if(t.logos?.[0]?.href) return String(t.logos[0].href).replace(/^http:/,'https:'); if(t.abbreviation) return `https://a.espncdn.com/i/teamlogos/nhl/500/${t.abbreviation}.png`; return null; }

/* ---------- Supabase helpers (auth + players) ---------- */
let session=null, currentUser=null, displayName='';
function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',right:'16px',bottom:'16px',background:'#0f1318',border:'1px solid #264',padding:'8px 10px',borderRadius:'10px',zIndex:50}); document.body.appendChild(t); setTimeout(()=>t.remove(),1600); }

async function loadOrCreatePlayer(){
  if(!currentUser) return;
  const uid=currentUser.id;
  const { data, error } = await supa.from('players').select('*').eq('id',uid).maybeSingle();
  if(error){ console.error(error); return; }
  if(!data){
    const def = (currentUser.email||'user').split('@')[0];
    const { error:insErr } = await supa.from('players').insert({ id:uid, display_name:def });
    if(insErr){ console.error(insErr); }
    displayName=def;
  }else{
    displayName=data.display_name||'';
  }
  $('displayNameInput').value=displayName||'';
}

$('saveDisplayName').addEventListener('click', async ()=>{
  if(!currentUser) return;
  const name = ($('displayNameInput').value||'').trim(); if(!name) return;
  const { error } = await supa.from('players').upsert({ id: currentUser.id, display_name: name });
  if(!error){ displayName=name; toast('Saved ‚úì'); renderWeeklyBoards(); renderSeasonBoards(); }
});
$('logoutBtn').addEventListener('click', async ()=>{ await supa.auth.signOut(); location.reload(); });
$('loginPwForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  const email = $('liEmail').value.trim();
  const password = $('liPass').value;
  const { error } = await supa.auth.signInWithPassword({ email, password });
  if (error) { alert(error.message); return; }
  toast('Logged in ‚úì');
});
$('forgotLink').addEventListener('click', async (e) => {
  e.preventDefault();
  const email = prompt('Enter your account email:'); if (!email) return;
  const redirectTo = location.origin + location.pathname.replace(/[^/]*$/, '') + 'reset.html';
  const { error } = await supa.auth.resetPasswordForEmail(email, { redirectTo });
  if (error) { alert(error.message); return; }
  toast('Reset email sent.');
});

/* ---------- Picks (Supabase) ---------- */
function uniqLimit(arr){ const out=[]; const seen=new Set(); (arr||[]).forEach(x=>{ const id=String(x); if(!seen.has(id)){ seen.add(id); out.push(id); } }); return out.slice(0,MAX_PICKS); }
const CK_MY = uid => `picks:${WEEK_KEY}:${uid}`;
const CK_ALL = `allpicks:${WEEK_KEY}`;
const NAME_MEMO = new Map();

async function picksForUser(uid){
  const ck = CK_MY(uid);
  const cached = getCache(ck);
  if (cached) return cached;

  const { data, error } = await supa
    .from('picks')
    .select('game_id')
    .eq('user_id', uid)
    .eq('league','NHL')
    .eq('week_key', WEEK_KEY)
    .limit(MAX_PICKS);

  const list = error ? [] : uniqLimit((data||[]).map(r=>String(r.game_id)));
  setCache(ck, list, 180000); // 3-minute TTL instead of 15s
  return list;
}

async function setPick(uid, gameId){
  const gid = String(gameId);

  // If cache already has this pick, skip DB write (saves I/O)
  const myKey = CK_MY(uid);
  const cached = getCache(myKey);
  if (Array.isArray(cached) && cached.includes(gid)) return true;

  // Minimal write: single-row upsert
  const { error } = await supa.from('picks').upsert(
    [{ user_id: uid, league:'NHL', week_key: WEEK_KEY, game_id: gid }],
    { onConflict: 'user_id,league,week_key,game_id' }
  );
  if (error){ alert(error.message); return false; }

  // Optimistic cache update (avoid immediate re-read)
  const next = Array.isArray(cached) ? uniqLimit([...cached, gid]) : [gid];
  setCache(myKey, next, 180000); // 3 min TTL

  // Keep "all picks" cache in sync if present; otherwise let it refetch later
  const all = getCache(CK_ALL);
  if (Array.isArray(all)) {
    if (!all.some(r => r.user_id === uid && String(r.game_id) === gid)) {
      all.push({ user_id: uid, game_id: gid });
      setCache(CK_ALL, all, 180000);
    }
  } else {
    delCache(CK_ALL);
  }

  refreshBadgesUI().catch(()=>{});
  return true;
}

async function allPicksThisWeek(){
  const cached = getCache(CK_ALL);
  if (cached) return cached;

  const { data, error } = await supa
    .from('picks')
    .select('user_id, game_id')     // only what we need
    .eq('league','NHL')
    .eq('week_key', WEEK_KEY);

  if (error) {
    console.error('allPicksThisWeek:', error);
    return [];
  }

  const rows = data || [];
  // Cache longer to cut reads; but if empty, cache briefly to avoid ‚Äústuck blank‚Äù
  setCache(CK_ALL, rows, rows.length ? 180000 : 30000); // 3 min if data, else 30s
  return rows;
}

async function getDisplayNames(userIds){
  const ids = [...new Set(userIds||[])].filter(Boolean);
  if (!ids.length) return {};

  // hydrate memo from localStorage first (24h TTL per id)
  const NAME_CK = id => `name:${id}`;
  ids.forEach(id => {
    if (!NAME_MEMO.has(id)) {
      const cached = getCache(NAME_CK(id));
      if (cached) NAME_MEMO.set(id, cached);
    }
  });

  // only fetch what's still missing
  let need = ids.filter(id => !NAME_MEMO.has(id));
  if (need.length){
    // chunk to keep the IN(...) list small (reduces load & errors)
    const CHUNK = 50;
    for (let i = 0; i < need.length; i += CHUNK){
      const batch = need.slice(i, i + CHUNK);

      const { data, error } = await supa
        .from('players')
        .select('id,display_name')
        .in('id', batch);

      if (!error && Array.isArray(data)){
        // fill memo + localStorage
        data.forEach(r => {
          const val = r.display_name || r.id.slice(0,6);
          NAME_MEMO.set(r.id, val);
          setCache(NAME_CK(r.id), val, 24*60*60*1000); // 24h
        });
        // any ids not returned: fallback + cache to avoid refetch thrash
        batch.forEach(id => {
          if (!NAME_MEMO.has(id)) {
            const val = id.slice(0,6);
            NAME_MEMO.set(id, val);
            setCache(NAME_CK(id), val, 24*60*60*1000);
          }
        });
      } else {
        // on error, fallback for this batch (and cache) so we don't refetch immediately
        batch.forEach(id => {
          const val = id.slice(0,6);
          NAME_MEMO.set(id, val);
          setCache(NAME_CK(id), val, 5*60*1000); // short 5m on error
        });
      }
    }
  }

  const map = {};
  ids.forEach(id => map[id] = NAME_MEMO.get(id));
  return map;
}


/* ---------- push summaries into SQL; and read game score/box (IO-friendly) ---------- */

// Write from a small cohort of clients (~10%) so the DB gets fresh totals.
async function pushSummaryToSQL(gameId, summaryJson){
  // decide once per browser if this client is a writer
  const IS_WRITER = (()=>{
    const k='qp_writer';
    let v = localStorage.getItem(k);
    if (v == null){ v = Math.random() < 0.10 ? '1' : '0'; localStorage.setItem(k, v); }
    return v === '1';
  })();
  if (!IS_WRITER) return; // most clients skip to save I/O

  const gid = String(gameId);
  const now = Date.now();
  const _H = (window.__SUM_HASH ||= new Map()); // last signature written
  const _T = (window.__SUM_TIME ||= new Map()); // last write time

  // tiny signature of only things that matter
  const comp = summaryJson?.header?.competitions?.[0] || {};
  const st   = comp?.status?.type || {};
  let home=null, away=null;
  (comp.competitors||[]).forEach(c=>{ if(c.homeAway==='home') home=c; if(c.homeAway==='away') away=c; });
  const a = Number(away?.score||0), h = Number(home?.score||0);
  const sig = JSON.stringify({ a, h, sid: st.id||st.shortDetail||st.name||'' });

  // only after start / when scores exist
  const state = String(st.state||st.name||'').toLowerCase();
  const started = state !== 'pre' || (a + h) > 0;
  if (!started) return;

  // debounce to ~15s while live
  const MIN_INTERVAL_MS = 15_000;
  if ((now - (_T.get(gid)||0)) < MIN_INTERVAL_MS) return;
  if (_H.get(gid) === sig) return;

  _T.set(gid, now);
  _H.set(gid, sig);

  const { error } = await supa.rpc('upsert_nhl_game_from_summary', {
    p_week_key: WEEK_KEY,
    p_game_id: gid,
    p_summary: summaryJson
  });
  if (error){
    console.error('upsert_nhl_game_from_summary:', error.message);
    _H.delete(gid); // allow retry next tick
  }
}

/* include stat fields ‚Äî low I/O + responsive */
const __gsCache     = window.__gsCache     || (window.__gsCache = new Map()); // key -> {row,t,ttl}
const __gsInflight  = window.__gsInflight  || (window.__gsInflight = new Map());
const __DB_TIMEOUT  = 2500;   // soft timeout so UI never stalls


async function getGameScoreFromDB(gid){
  const key = String(gid);
  const now = Date.now();
  const cached = __gsCache.get(key);

  // 1) Fresh cache -> return
  if (cached && (now - cached.t) < (cached.ok ? __HIT_TTL_MS : __MISS_TTL_MS)) {
    return cached.row;
  }

  // 2) If a fetch is already running for this gid, piggyback on it
  if (__gsInflight.has(key)) {
    try {
      return await __gsInflight.get(key);
    } catch {
      // fall through to stale value / null
    }
  }

  // 3) Make a timed query (soft timeout)
  const query = (async () => {
    const { data, error } = await supa
      .from('game_scores')
      .select('total,home_pts,away_pts,close_bonus,ot_bonus,so_bonus,is_final,goals,ppg,shg,shots,saves,hits,blocks,pim')
      .eq('league','NHL')
      .eq('week_key', WEEK_KEY)
      .eq('game_id', key)
      .maybeSingle();

    const ok = !error && !!data;
    const row = ok ? data : null;

    // 4) Never downgrade a good cached row to null; keep last good row as stale
    if (!ok && cached && cached.ok && cached.row){
      __gsCache.set(key, { row: cached.row, t: now, ok: true });
      return cached.row;
    }

    __gsCache.set(key, { row, t: now, ok });
    return row;
  })();

  // Wrap with timeout
  const timed = Promise.race([
    query,
    new Promise((resolve) => setTimeout(() => resolve(Symbol('timeout')), __DB_TIMEOUT))
  ]);

  __gsInflight.set(key, timed);

  try {
    const res = await timed;
    if (res !== Symbol.for && res !== Symbol('timeout')) {
      return res; // got DB result in time
    }
    // timed out: serve stale if we have it, else null (no cache change)
    if (cached && cached.row) return cached.row;
    return null;
  } finally {
    __gsInflight.delete(key);
  }
}


/* ---------- Robust Scoring detector + helpers ---------- */
function mapPlay(x){
  return {
    raw:x,
    per: x?.period?.number ?? x?.periodNumber ?? x?.period ?? '?',
    clk: x?.clock?.displayValue ?? x?.clock ?? '',
    text: (x?.text || x?.description || x?.shortText || '').replace(/\s+/g,' ').trim()
  };
}
function isRealGoal(pRaw){
  const typeText = (pRaw?.type?.text || '').toLowerCase();
  const bodyText = (pRaw?.text || pRaw?.description || pRaw?.shortText || '').toLowerCase();
  if (pRaw?.scoringPlay === true) return true;
  if (pRaw?.type?.id === '521') return true; // ESPN "Goal"
  const hasGoalWord = /\bgoal\b/i.test(typeText) || /\bgoal\b/i.test(bodyText);
  const isNeg = /\bno goal\b|\bgoalie\b|\bstopped\b|\bsave\b|\bsaved\b|\bdisallowed\b/i.test(typeText + ' ' + bodyText);
  return hasGoalWord && !isNeg;
}
async function getScoringPlaysRobust(eventId, summaryJson){
  // 1) Try summary first (free ‚Äî already fetched)
  let list = (summaryJson?.scoringPlays || []).map(mapPlay);
  if (!list.length) {
    const alt = (summaryJson?.allPlays || summaryJson?.plays || []).filter(isRealGoal).map(mapPlay);
    list = alt;
    if (list.length) {
      // de-dupe and return without any extra network I/O
      const seen = new Set(), out = [];
      for (const p of list){ const k=`${p.per}|${p.clk}|${p.text}`; if(!seen.has(k)){ seen.add(k); out.push(p); } }
      return out;
    }
  }

  // 2) If summary had scoring plays, just return them (no extra fetch)
  if (list.length) {
    const seen = new Set(), out = [];
    for (const p of list){ const k=`${p.per}|${p.clk}|${p.text}`; if(!seen.has(k)){ seen.add(k); out.push(p); } }
    return out;
  }

  // 3) Cache play-by-play so we don't refetch constantly
  const CK = `pbp:${eventId}`;
  const cached = getCache(CK);
  if (cached) return cached;

  // 4) Fetch play-by-play (no cache-buster in URL; safeJson/dedup handles inflight)
  const pbpUrl = `https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/playbyplay?event=${eventId}`;
  let out = [];
  try {
    const pbp = await safeJson(pbpUrl).catch(()=>null);
    const fromPbp = (pbp?.allPlays || pbp?.plays || [])
      .filter(isRealGoal)
      .map(mapPlay);

    // de-dupe
    const seen = new Set();
    for (const p of fromPbp){
      const k = `${p.per}|${p.clk}|${p.text}`;
      if (!seen.has(k)){ seen.add(k); out.push(p); }
    }
  } catch {
    out = [];
  }

  // 5) Cache result: longer if we have data, short if empty to avoid hammering
  setCache(CK, out, out.length ? 120000 : 30000); // 2m if data, else 30s
  return out;
}

async function getRecentPlays(eventId, summaryJson){
  // 1) Start with summaryJson if it has plays (free)
  let arr = (summaryJson?.allPlays || summaryJson?.plays || []);
  if (arr.length) return arr.map(mapPlay);

  // 2) Check local cache before hitting ESPN
  const CK = `recent:${eventId}`;
  const cached = getCache(CK);
  if (cached) return cached;

  // 3) Fetch play-by-play only if needed (no Date.now() busting)
  const pbpUrl = `https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/playbyplay?event=${eventId}`;
  let plays = [];
  try {
    const pbp = await safeJson(pbpUrl).catch(()=>null);
    plays = (pbp?.allPlays || pbp?.plays || []).map(mapPlay);
  } catch {
    plays = [];
  }

  // 4) Cache: keep data longer if we got some, shorter if empty
  setCache(CK, plays, plays.length ? 120000 : 30000); // 2m if data, 30s if empty
  return plays;
}

/* ---------- League (NHL) UI ---------- */
function leagueFactory(){
  const st={ events:[], selected:null, poll:null, gameRows:[] };
  const dom={ gridCard:$('nhl-gridCard'), note:$('nhl-note'), grid:$('nhl-grid'), top:$('nhl-top'), back:$('nhl-back'), add:$('nhl-addPick'), live:$('nhl-liveHeader'), teamSide:$('nhl-teamSide'), fscore:$('nhl-fscore'), bonus:$('nhl-bonuses'), clock:$('nhl-clock'), q:$('nhl-q'), state:$('nhl-state'), gameLB:$('nhl-gameLB') };
  const api={ scoreboard:(d)=>`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard?dates=${d.replace(/-/g,'')}`, summary:(id)=>`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/summary?event=${id}` };

  dom.back.addEventListener('click', ()=>{ dom.top.style.display='none'; dom.gridCard.style.display='block'; st.selected=null; });
  dom.add.addEventListener('click', async ()=>{
    if(!currentUser){ alert('Sign in first.'); return; }
    if(!st.selected) return;
    const kick=new Date(st.selected.start).getTime();
    if(Date.now()>=kick){ alert('Locked (already started)'); return; }
    const myList = await picksForUser(currentUser.id);
    const gid=String(st.selected.id);
    if(myList.includes(gid)){ alert('Already picked.'); return; }
    if(myList.length>=MAX_PICKS){ alert(`You already have ${MAX_PICKS} picks in NHL.`); return; }
    const ok = await setPick(currentUser.id,gid);
    if(ok){
      updatePicksLeft();
      renderWeeklyBoards();
      renderMyPicks();
      const tag=$(`picked-${st.selected.id}`); if(tag) tag.style.display='inline-flex';
      const btn=document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none';
      toast('Pick saved ‚úì');
    }
  });

  function renderGrid(){
  const evs = st.events || [];
  const now = Date.now();

  // Build all cards at once to minimize DOM I/O
  dom.grid.innerHTML = evs.map(g=>{
    const started = now >= new Date(g.start).getTime();
    const puck = new Date(g.start).toLocaleString([], {
      weekday:'short', month:'short', day:'numeric', hour:'numeric', minute:'2-digit'
    });
    const gid = String(g.id);

    return `
      <div class="gameCard" data-gid="${gid}">
        <div class="band" style="background:linear-gradient(90deg, ${g.away.color?('#'+g.away.color):'#1a232d'} 0%, ${g.home.color?('#'+g.home.color):'#26313c'} 100%)"></div>
        <div class="gameBody">
          <div class="teamsRow">
            <div class="team">
              ${g.away.logo ? `<img loading="lazy" src="${g.away.logo}" alt="">` : ``}
              <div class="name">${g.away.name}</div>
              <span class="scoreTag" id="NHL-a-${gid}">0</span>
            </div>
            <div class="small" style="opacity:.8">@</div>
            <div class="team" style="justify-content:flex-end">
              ${g.home.logo ? `<img loading="lazy" src="${g.home.logo}" alt="">` : ``}
              <div class="name">${g.home.name}</div>
              <span class="scoreTag" id="NHL-h-${gid}">0</span>
            </div>
          </div>

          <div class="small" style="margin-top:6px;opacity:.9">
            Score: <span id="NHL-scr-${gid}">‚Äî</span> ¬∑
            <span id="NHL-st-${gid}">pre</span> ¬∑
            Puck drop: ${puck}
          </div>

          <div class="small" style="margin-top:8px">
            <span id="NHL-fant-${gid}-wrap"
                  style="display:inline-flex;align-items:center;gap:8px;
                         background:#0e1a14;border:1px solid #2e5e3f;color:#9be7b0;
                         padding:6px 12px;border-radius:999px;font-weight:800;
                         letter-spacing:.2px;">
              <span style="opacity:.9">Fantasy</span>
              <span id="NHL-fant-${gid}" style="font-variant-numeric:tabular-nums">‚Äî</span>
            </span>
          </div>

          <div class="lockRow">
            <span class="pickedTag" style="display:none" id="picked-${gid}">‚úì Picked</span>
            <button class="btn pickBtn" data-gid="${gid}" ${started ? 'style="display:none"' : ''}>Add to my picks</button>
            <button class="btn small viewBtn" data-gid="${gid}">Open</button>
          </div>

          ${started ? '<div class="small" style="color:#c78;margin-top:6px">Locked (already started)</div>' : ''}
        </div>
      </div>`;
  }).join('');

  // Event delegation (attach once) ‚Üí fewer listeners, less DOM I/O
  if (!dom.grid._wired) {
    dom.grid.addEventListener('click', async (e)=>{
      const viewBtn = e.target.closest('.viewBtn');
      if (viewBtn) {
        const gid = viewBtn.getAttribute('data-gid');
        const g = (st.events||[]).find(x => String(x.id) === String(gid));
        if (g) openGame(g);
        return;
      }

      const pickBtn = e.target.closest('.pickBtn');
      if (pickBtn) {
        if (!currentUser) { alert('Sign in first.'); return; }
        const gid = pickBtn.getAttribute('data-gid');
        const g = (st.events||[]).find(x => String(x.id) === String(gid));
        if (!g) return;

        if (Date.now() >= new Date(g.start).getTime()) { alert('Locked (already started)'); return; }

        const myList = await picksForUser(currentUser.id);
        if (myList.includes(gid)) { alert('Already picked.'); return; }
        if (myList.length >= MAX_PICKS) { alert(`You already have ${MAX_PICKS} picks in NHL.`); return; }

        const ok = await setPick(currentUser.id, gid);
        if (ok) {
          updatePicksLeft();
          renderWeeklyBoards();
          renderMyPicks();
          const tag = $(`picked-${gid}`); if (tag) tag.style.display='inline-flex';
          pickBtn.style.display='none';
          toast('Pick saved ‚úì');
        }
      }
    });
    dom.grid._wired = true;
  }
}

  async function refreshGridScores(){
  const evs = st.events || [];
  if (!evs.length) return;

  // ---- 0) helpers ----
  const getSummary = (id) => (typeof st.fetchSummary === 'function'
    ? st.fetchSummary(id)
    : safeJson(api.summary(id)));

  // ---- 1) FAST PATH: get ESPN first and paint scores immediately ----
  const espnArr = await pLimitAll(evs, 4, async (g) => {
    try {
      const s = await getSummary(g.id);
      const comp = s?.header?.competitions?.[0] || {};
      let homeC = null, awayC = null;
      (comp.competitors || []).forEach(c => {
        if (c.homeAway === 'home') homeC = c;
        if (c.homeAway === 'away') awayC = c;
      });
      return {
        id: String(g.id),
        a: Number(awayC?.score ?? 0),
        h: Number(homeC?.score ?? 0),
        st: (comp.status?.type?.shortDetail || comp.status?.type?.description || '‚Äî')
      };
    } catch {
      return { id:String(g.id), a:0, h:0, st:'‚Äî' };
    }
  });

  // Paint ESPN scores/status right away so UI feels instant
  for (const r of espnArr){
    const scEl = $(`NHL-scr-${r.id}`); if (scEl) scEl.textContent = `${r.a}‚Äì${r.h}`;
    const stEl = $(`NHL-st-${r.id}`);  if (stEl) stEl.textContent = r.st;
    const aEl  = $(`NHL-a-${r.id}`);   if (aEl)  aEl.textContent  = r.a;
    const hEl  = $(`NHL-h-${r.id}`);   if (hEl)  hEl.textContent  = r.h;
  }

  // ---- 2) SLOW PATH: one bulk DB read for fantasy totals (and canonical pts) ----
  const ids = evs.map(g => String(g.id));
  let scoreMap = new Map();
  try {
    const { data, error } = await supa
      .from('game_scores')
      .select('game_id, away_pts, home_pts, total')
      .eq('league','NHL')
      .eq('week_key', WEEK_KEY)
      .in('game_id', ids);

    if (!error && Array.isArray(data)) {
      scoreMap = new Map(data.map(r => [String(r.game_id), r]));
    }
  } catch {
    // ignore; we already painted ESPN numbers
  }

  // ---- 3) Merge ESPN + DB ‚Üí final rows ----
  const espnMap = new Map(espnArr.map(r => [r.id, r]));
  const rows = ids.map(id => {
    const e  = espnMap.get(id) || { a:0, h:0, st:'‚Äî' };
    const db = scoreMap.get(id);
    return {
      id,
      awayPts: (db?.away_pts ?? e.a),
      homePts: (db?.home_pts ?? e.h),
      score:   (db?.total ?? 0),
      status:  e.st
    };
  });

  // ---- 4) Paint fantasy totals (score) only now; keep earlier score/status text ----
  for (const r of rows){
    const fEl = $(`NHL-fant-${r.id}`);
    if (fEl) fEl.textContent = Number(r.score || 0).toFixed(2);
  }

  // ---- 5) Build leaderboard rows (unchanged shape) ----
  st.gameRows = evs.map(g=>{
    const r = rows.find(x => x.id === String(g.id));
    if(!r) return null;
    return {
      id: g.id,
      awayName: g.away.name, homeName: g.home.name,
      awayLogo: g.away.logo, homeLogo: g.home.logo,
      score: r.score, status: r.status
    };
  }).filter(Boolean).sort((a,b)=>b.score-a.score);

  renderGameLB();
  renderUserLB();
}


  function renderGameLB(){
  if (!st.gameRows) return;
  const tgt = $('nhl-gameLB'); if (!tgt) return;

  // Build HTML once (with lazy images) and only touch DOM if it actually changed
  const html = (st.gameRows || []).map(r => {
    const pts = Number(r.score || 0).toFixed(2);
    const aImg = r.awayLogo ? `<img loading="lazy" src="${r.awayLogo}" alt="">` : '';
    const hImg = r.homeLogo ? `<img loading="lazy" src="${r.homeLogo}" alt="" style="margin-left:6px">` : '';
    return `
      <div class="lbRow" data-gid="${r.id}" style="cursor:pointer" role="button" tabindex="0" aria-label="Open ${r.awayName} at ${r.homeName}">
        <div class="lbTeam">
          ${aImg}
          <span class="lbName" style="max-width:280px">${r.awayName} @ ${r.homeName}</span>
          ${hImg}
        </div>
        <div class="lbPts">${pts}</div>
        <div class="small">${r.status || ''}</div>
      </div>`;
  }).join('');

  // Avoid unnecessary DOM I/O: only re-render if content actually differs
  if (tgt._lastHTML !== html) {
    // Batch the write on the next frame to keep layout smooth
    (window.requestAnimationFrame || function(fn){ return setTimeout(fn,0); })(() => {
      tgt.innerHTML = html;
      tgt._lastHTML = html;
    });
  }

  // Event delegation (attach once)
  if (!tgt._wired){
    tgt.addEventListener('click', (e)=>{
      const row = e.target.closest('.lbRow[data-gid]'); if(!row) return;
      const id = row.getAttribute('data-gid');
      const g = (NHL && NHL.state && NHL.state.events || []).find(x => String(x.id) === String(id));
      if (g) openGame(g);
    });
    tgt.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){
        const row = e.target.closest('.lbRow[data-gid]'); if(!row) return;
        const id = row.getAttribute('data-gid');
        const g = (NHL && NHL.state && NHL.state.events || []).find(x => String(x.id) === String(id));
        if (g){ e.preventDefault(); openGame(g); }
      }
    });
    tgt._wired = true;
  }
}

 function openGame(g){
  // Select game and paint header/team sides (no network I/O here)
  st.selected = g;
  $('nhl-top').setAttribute('data-show','true');
  dom.live.textContent = `${g.away.name} @ ${g.home.name}`;
  dom.teamSide.innerHTML =
    `<div class="teamline" style="border-left:6px solid ${g.away.color?('#'+g.away.color):'#2a3643'}">
       <div style="display:flex;gap:10px;align-items:center">
         ${g.away.logo?`<img loading="lazy" src="${g.away.logo}" alt="">`:''}
         <div style="font-weight:700">${g.away.name}</div>
       </div>
       <div id="NHL-awayScore" style="font-weight:800">‚Äî</div>
     </div>
     <div class="teamline" style="border-left:6px solid ${g.home.color?('#'+g.home.color):'#2a3643'}">
       <div style="display:flex;gap:10px;align-items:center">
         ${g.home.logo?`<img loading="lazy" src="${g.home.logo}" alt="">`:''}
         <div style="font-weight:700">${g.home.name}</div>
       </div>
       <div id="NHL-homeScore" style="font-weight:800">‚Äî</div>
     </div>`;

  dom.gridCard.style.display = 'none';
  dom.top.style.display = 'block';

  // --- I/O-friendly polling: dedup + throttle + pause when hidden ---
  // Immediate paint once (don‚Äôt wait for interval)
  updateGameOnce();

  // Clear any old timer
  if (st.poll) clearInterval(st.poll);

  // Adaptive gap based on network; floor at 20s to keep UI fresh
  const conn = (navigator.connection || {});
  const baseGap = ({
    'slow-2g': 35000, '2g': 30000, '3g': 25000, '4g': 20000
  }[conn.effectiveType]) || 20000;

  // Per-game guards so we don‚Äôt stack requests
  st._lastTick = 0;
  st._updating = false;

  async function tick(){
    // Skip work if tab not visible ‚Üí saves ESPN/DB I/O
    if (document.hidden) return;

    const now = Date.now();
    if (now - st._lastTick < baseGap) return;
    if (st._updating) return;
    st._updating = true;
    try{
      await updateGameOnce();
      st._lastTick = now;
    } finally {
      st._updating = false;
    }
  }

  // Poller: lightweight; tick itself decides whether to actually fetch
  st.poll = setInterval(tick, 2000); // cheap heartbeat; real gap enforced in tick()

  // When user returns to tab, refresh immediately (no extra intervals)
  if (!st._visHooked){
    document.addEventListener('visibilitychange', ()=>{
      if (!document.hidden) { st._lastTick = 0; tick(); }
    });
    st._visHooked = true;
  }

  renderGameLB();
  renderUserLB();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

  function renderBreakdown(row){
    const W = { goal:4, ppg:1.5, shg:1.0, sog:0.1, sv:0.05, hit:0.05, block:0.05, pim:-0.1, close:4, ot:2, so:2 };
    const safe = n => Number(n||0);
    const items = [
      { label:'Goals',         count:safe(row.goals),  per:W.goal,  pts:safe(row.goals)*W.goal },
      { label:'PowerPlay Goals',  count:safe(row.ppg),    per:W.ppg,   pts:safe(row.ppg)*W.ppg },
      { label:'Shorthanded Goals',count:safe(row.shg),    per:W.shg,   pts:safe(row.shg)*W.shg },
      { label:'Shots on Goal', count:safe(row.shots),  per:W.sog,   pts:safe(row.shots)*W.sog },
      { label:'Saves',         count:safe(row.saves),  per:W.sv,    pts:safe(row.saves)*W.sv },
      { label:'Hits',          count:safe(row.hits),   per:W.hit,   pts:safe(row.hits)*W.hit },
      { label:'Blocked Shots', count:safe(row.blocks), per:W.block, pts:safe(row.blocks)*W.block },
      { label:'Penalty Minutes',count:safe(row.pim),   per:W.pim,   pts:safe(row.pim)*W.pim },
    ];
    const tbody = document.querySelector('#nhl-breakdown tbody');
    if(!tbody) return;
    tbody.innerHTML = items.map(it=>`
      <tr>
        <td>${it.label}</td>
        <td>${it.count}</td>
        <td>${it.per.toFixed(2)}</td>
        <td>${it.pts.toFixed(2)}</td>
      </tr>`).join('');

    const bonus = safe(row.close_bonus)+safe(row.ot_bonus)+safe(row.so_bonus);
    const offenseDefense = items.reduce((s,x)=>s+x.pts,0);
    const total = offenseDefense + bonus;

    const bdBonuses = document.getElementById('bd-bonuses');
    const bdTotal = document.getElementById('bd-total');
    if(bdBonuses) bdBonuses.textContent = bonus.toFixed(2);
    if(bdTotal) bdTotal.textContent = (row?.total!=null ? Number(row.total).toFixed(2) : total.toFixed(2));

    const cb = safe(row.close_bonus), ob=safe(row.ot_bonus), sb=safe(row.so_bonus);
    document.getElementById('nhl-bonuses').textContent =
      `Bonuses: ${cb?`Close +${cb}`:'‚Äî'} ¬∑ ${ob?`OT +${ob}`:'‚Äî'} ¬∑ ${sb?`SO +${sb}`:'‚Äî'}`;
  }

  async function updateGameOnce(){
  if (!st.selected) return;
  const id = String(st.selected.id);

  // --- tiny per-tab caches (safe globals) ---
  const SUM_TTL_MS   = 60_000;  // cache ESPN summary 60s
  const PLAYS_TTL_MS = 30_000;  // cache plays lists 30s

  const sumCache   = (window.__sumCache   ||= new Map()); // id -> {t,s}
  const playsCache = (window.__playsCache ||= new Map()); // id -> {t,scoring,recent}

  // helper: get summary with cache (prefer st.fetchSummary if present)
  const getSummary = async (gid) => {
    const now = Date.now();
    const hit = sumCache.get(gid);
    if (hit && (now - hit.t) < SUM_TTL_MS) return hit.s;

    const p = (typeof st.fetchSummary === 'function'
      ? st.fetchSummary(gid)
      : safeJson(api.summary(gid)));

    const s = await p.catch(() => null);
    if (s) sumCache.set(gid, { t: now, s });
    return s;
  };

  try {
    // 1) ESPN summary (fast path)
    const s = await getSummary(id);
    const comp = s?.header?.competitions || [];
    const c0 = (comp[0] || {});
    const status = c0.status || {};
    let homeC = null, awayC = null;
    (c0.competitors || []).forEach(c => {
      if (c.homeAway === 'home') homeC = c;
      if (c.homeAway === 'away') awayC = c;
    });

    // 2) (no-op if CLIENT_WRITES=false) ‚Äì safe to keep call
    await pushSummaryToSQL(id, s);

    // 3) DB totals (soft-timeout handled inside getGameScoreFromDB in your code)
    const row = await getGameScoreFromDB(id);

    // 4) Paint scores / clock / status right away (fallback to ESPN if DB missing)
    $('NHL-homeScore').textContent = String(row?.home_pts ?? homeC?.score ?? 0);
    $('NHL-awayScore').textContent = String(row?.away_pts ?? awayC?.score ?? 0);
    $('nhl-clock').textContent     = status.displayClock || '‚Äî';
    $('nhl-q').textContent         = String(status.period ?? '‚Äî');
    $('nhl-state').textContent     = (status.type?.description || status.type?.shortDetail || '‚Äî');
    $('nhl-fscore').textContent    = (row?.total != null ? Number(row.total).toFixed(2) : '‚Äî');

    if (row) renderBreakdown(row);

    // 5) Scoring/Recent plays ‚Äî throttle + cache to cut extra ESPN calls
    const now = Date.now();
    const hit = playsCache.get(id);
    let scoring = hit && (now - hit.t) < PLAYS_TTL_MS ? hit.scoring : null;
    let recent  = hit && (now - hit.t) < PLAYS_TTL_MS ? hit.recent  : null;

    if (!scoring || !recent) {
      // These helpers are already I/O-friendly (try summary first, avoid extra fetches)
      scoring = await getScoringPlaysRobust(id, s);
      recent  = await getRecentPlays(id, s);
      playsCache.set(id, { t: now, scoring, recent });
    }

    const scoreBox  = document.getElementById('nhl-scoreList');
    const recentBox = document.getElementById('nhl-recentList');

    if (scoreBox){
      scoreBox.innerHTML = scoring.length
        ? scoring.slice(-20).reverse().map(sp =>
            `<div class="play"><span class="dot goal"></span>
               <div><div>${sp.text}</div><div class="when">[P${sp.per} ${sp.clk}]</div></div></div>`
          ).join('')
        : '<div class="small">No data yet.</div>';
    }

    if (recentBox){
      recentBox.innerHTML = recent.length
        ? recent.slice(-30).reverse().map(p =>
            `<div class="play"><span class="dot other"></span>
               <div><div>${p.text}</div><div class="when">[P${p.per} ${p.clk}]</div></div></div>`
          ).join('')
        : '<div class="small">No data yet.</div>';
    }
  } catch (e) {
    // swallow errors to keep UI responsive
  }
}

  async function loadWeek(){
    dom.note.textContent=`Loading NHL games for ${WEEK.start} ‚Üí ${WEEK.end} ‚Ä¶`;
    const all=[];
    for(const d of WEEK.list){
      const sb=await safeJson(api.scoreboard(d)).catch(()=>null);
      const evs=sb?.events||[];
      for(const ev of evs){
        const c=ev.competitions?.[0]||{};
        let home=null,away=null; (c.competitors||[]).forEach(x=>{ if(x.homeAway==='home') home=x; if(x.homeAway==='away') away=x; });
        all.push({
          id:ev.id,
          start:ev.date,
          home:{ name:home?.team?(home.team.shortDisplayName||home.team.displayName):'Home', color:home?.team?.color||null, logo:cdnNHL(home?.team||null) },
          away:{ name:away?.team?(away.team.shortDisplayName||away.team.displayName):'Away', color:away?.team?.color||null, logo:cdnNHL(away?.team||null) }
        });
      }
    }
    all.sort((a,b)=>new Date(a.start)-new Date(b.start));
    st.events=all;
    dom.note.textContent=`${all.length} games`;
    renderGrid();
    if(currentUser){
      const mine = await picksForUser(currentUser.id);
      mine.forEach(gid=>{ const tag=$(`picked-${gid}`); if(tag) tag.style.display='inline-flex'; const btn=document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none'; });
    }
    refreshGridScores();
    setInterval(refreshGridScores,30000);
  }

  function renderUserLB(){ /* minimal on this tab */ }

  return { loadWeek, state:st };
}
const NHL = leagueFactory();

/* ---------- DB-driven helpers for boards/picks ---------- */
function ordinal(n){ const s=["th","st","nd","rd"], v=n%100; return n+ (s[(v-20)%10]||s[v]||s[0]); }

async function renderWeeklyBoards(){
  const box=$('lbNHLWeek');
  if(!box) return;
  box.innerHTML='<div class="small">Loading‚Ä¶</div>';
  const { data, error } = await supa.from('weekly_results').select('user_id,total,rank').eq('league','NHL').eq('week_key',WEEK_KEY).order('rank');
  if(error){ console.error(error); box.innerHTML='<div class="small">Error.</div>'; return; }
  if(!data || !data.length){ box.innerHTML='<div class="small">No results yet.</div>'; return; }
  const names=await getDisplayNames(data.map(r=>r.user_id));
  box.innerHTML='';
  data.forEach(r=>{
    const div=document.createElement('div'); div.className='lbRow';
    div.innerHTML=`<span class="lbPos">${r.rank}</span><div class="lbTeam"><span class="lbName">${names[r.user_id]||r.user_id.slice(0,6)}</span></div><div class="lbPts">${Number(r.total).toFixed(2)}</div><div class="small">Weekly</div>`;
    box.appendChild(div);
  });
}

async function renderSeasonBoards(){
  const box=$('lbNHLSeason'); if(!box) return;
  box.innerHTML='<div class="small">Loading‚Ä¶</div>';
  const { data, error } = await supa.from('season_points').select('user_id, points').eq('league','NHL').order('points', { ascending:false });
  if(error){ console.error(error); box.innerHTML='<div class="small">Error.</div>'; return; }
  if(!data || !data.length){ box.innerHTML='<div class="small">No season data yet.</div>'; return; }
  const names=await getDisplayNames(data.map(r=>r.user_id));
  box.innerHTML='';
  data.forEach((r,i)=>{
    const div=document.createElement('div'); div.className='lbRow';
    div.innerHTML=`<span class="lbPos">${i+1}</span><div class="lbTeam"><span class="lbName">${names[r.user_id]||r.user_id.slice(0,6)}</span></div><div class="lbPts">${r.points}</div><div class="small">Season</div>`;
    box.appendChild(div);
  });
}

/* ---------- My Picks ---------- */
const RENDER_TICKETS = new Map();
function nextTicket(key){ const n=(RENDER_TICKETS.get(key)||0)+1; RENDER_TICKETS.set(key,n); return n; }
function isCurrent(key,t){ return RENDER_TICKETS.get(key)===t; }
let LAST_ALL_IDS_JSON = '';

function gameRowHTML(meta,score){
  return `<div class="lbTeam">${meta.awayLogo?`<img src="${meta.awayLogo}" alt="">`:''}<span class="lbName" style="max-width:280px">${meta.awayName} @ ${meta.homeName}</span>${meta.homeLogo?`<img src="${meta.homeLogo}" alt="" style="margin-left:6px">`:''}</div><div class="lbPts">${Number(score||0).toFixed(2)}</div><div class="small">Game</div>`;
}
// I/O-friendly drop-in: caches success for 24h, failures briefly, dedups concurrent fetches,
// and prefers already-loaded event data over hitting ESPN.
async function gameMeta(gid){
  const key = String(gid);
  const ck  = `meta:${key}`;

  // global memos (safe on window)
  const memo        = (window.__metaMemo        ||= new Map()); // game_id -> {v,t,ok}
  const inflight    = (window.__metaInflight    ||= new Map()); // game_id -> Promise
  const teamMemo    = (window.__teamMetaMemo    ||= new Map()); // teamKey -> {v,t}
  const now         = Date.now();

  // TTLs
  const HIT_TTL   = 24*60*60*1000;  // 24h for good game meta
  const MISS_TTL  = 10*60*1000;     // 10m for misses
  const TEAM_TTL  = 7*24*60*60*1000; // 7d for team name/logo (rarely change)

  // --- 1) fresh in-memory game cache?
  const mHit = memo.get(key);
  if (mHit && (now - mHit.t) < (mHit.ok ? HIT_TTL : MISS_TTL)) return mHit.v;

  // --- 2) localStorage game cache?
  const ls = getCache(ck);
  if (ls) {
    memo.set(key, { v: ls, t: now, ok: !!(ls.awayLogo || ls.homeLogo) });
    return ls;
  }

  // helper: build team object using per-team memo (cuts repeated work across games)
  function teamKey(t){
    // prefer stable ids; fall back to abbreviation/name
    return t?.id ? `id:${t.id}` : (t?.abbreviation ? `abbr:${t.abbreviation}` : (t?.name ? `nm:${t.name}` : ''));
  }
  function teamMeta(t){
    if (!t) return { name:'', logo:null };
    const tk = teamKey(t) || '';
    if (tk){
      const thit = teamMemo.get(tk);
      if (thit && (now - thit.t) < TEAM_TTL) return thit.v;
    }
    const v = {
      name: (t.shortDisplayName || t.displayName || t.name || '').trim() || '',
      logo: cdnNHL(t) || null
    };
    if (teamKey(t)) teamMemo.set(teamKey(t), { v, t: now });
    return v;
  }

  // --- 3) from already loaded schedule (free)
  try{
    const ev = (window.NHL && NHL.state && Array.isArray(NHL.state.events))
      ? NHL.state.events.find(e => String(e.id) === key)
      : (typeof st !== 'undefined' && st && Array.isArray(st.events) ? st.events.find(e => String(e.id) === key) : null);

    if (ev){
      const v = {
        awayName: ev.away?.name || '',
        homeName: ev.home?.name || '',
        awayLogo: ev.away?.logo || null,
        homeLogo: ev.home?.logo || null
      };
      memo.set(key, { v, t: now, ok: !!(v.awayLogo || v.homeLogo) });
      setCache(ck, v, HIT_TTL);
      return v;
    }
  }catch{ /* ignore */ }

  // --- 4) piggyback if another fetch is in-flight
  if (inflight.has(key)) {
    try { return await inflight.get(key); } catch { /* fall through */ }
  }

  // --- 5) ESPN summary only if needed (uses st.fetchSummary if provided)
  const fetchSummary = (typeof st?.fetchSummary === 'function')
    ? st.fetchSummary
    : (id)=>safeJson(`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/summary?event=${id}`);

  const p = (async ()=>{
    try{
      const s = await fetchSummary(key).catch(()=>null);
      const comp = s?.header?.competitions?.[0] || {};
      let home=null, away=null;
      (comp.competitors || []).forEach(x => {
        if (x.homeAway === 'home') home = x;
        if (x.homeAway === 'away') away = x;
      });

      const a = teamMeta(away?.team || null);
      const h = teamMeta(home?.team || null);

      const v = {
        awayName: a.name || 'Away',
        homeName: h.name || 'Home',
        awayLogo: a.logo,
        homeLogo: h.logo
      };

      const ok = !!(v.awayLogo || v.homeLogo);
      memo.set(key, { v, t: now, ok });
      setCache(ck, v, ok ? HIT_TTL : MISS_TTL);
      return v;
    }catch{
      const v = { awayName:'Away', homeName:'Home', awayLogo:null, homeLogo:null };
      memo.set(key, { v, t: now, ok:false });
      setCache(ck, v, MISS_TTL);
      return v;
    }
  })();

  inflight.set(key, p);
  try { return await p; }
  finally { inflight.delete(key); }
}

async function renderPickList(containerId, gidList){
  const el = $(containerId);
  const myTicket = nextTicket(containerId);
  const clean = uniqLimit(gidList || []).map(String);

  el.innerHTML = '';
  if (clean.length === 0){
    if (isCurrent(containerId, myTicket)) el.innerHTML = '<div class="small">No picks yet.</div>';
    return 0;
  }

  // ---- 1) ONE bulk DB read for all game totals ----
  let scoreMap = new Map();
  try{
    const { data, error } = await supa
      .from('game_scores')
      .select('game_id,total')
      .eq('league','NHL')
      .eq('week_key', WEEK_KEY)
      .in('game_id', clean);

    if (!error && Array.isArray(data)){
      scoreMap = new Map(data.map(r => [String(r.game_id), Number(r.total || 0)]));
    }
  }catch{ /* fall through; we'll treat as 0s */ }

  // ---- 2) Meta for each game (cached/schedule-first; no DB/ESPN writes) ----
  const metas = await pLimitAll(clean, 3, async (gid) => {
    try { return await gameMeta(gid); }
    catch { return { awayName:'Away', homeName:'Home', awayLogo:null, homeLogo:null }; }
  });

  if (!isCurrent(containerId, myTicket)) return 0;

  // ---- 3) Build rows + total (batch DOM write) ----
  let total = 0;
  const rows = [];
  for (let i = 0; i < clean.length; i++){
    const gid = clean[i];
    const meta = metas[i] || { awayName:'Away', homeName:'Home', awayLogo:null, homeLogo:null };
    const score = scoreMap.get(gid) || 0;
    total += score;
    rows.push(`<div class="lbRow">${gameRowHTML(meta, score)}</div>`);
  }
  el.innerHTML = rows.join('');
  return total;
}

async function renderMyPicks(){
  if(!currentUser){
    $('myNHL').innerHTML='<div class="small">Sign in to see your picks.</div>';
    $('allPicks').innerHTML='<div class="small">Sign in to see everyone.</div>';
    return;
  }
  const myList = await picksForUser(currentUser.id);
  const tot = await renderPickList('myNHL', myList);
  $('myNHLTotal').textContent = Number(tot||0).toFixed(2);

  const box=$('allPicks');
  const rows = await allPicksThisWeek();
  const byUser=new Map(); rows.forEach(r=>{ const a=byUser.get(r.user_id)||[]; a.push(String(r.game_id)); byUser.set(r.user_id,a); });
  const ids=[...byUser.keys()];
  if(!ids.length){ box.innerHTML='<div class="small">No picks yet.</div>'; return; }

  const idsJson = JSON.stringify(ids.slice().sort());
  if(idsJson !== LAST_ALL_IDS_JSON){
    LAST_ALL_IDS_JSON = idsJson;
    const names=await getDisplayNames(ids);
    const frags=[]; ids.forEach(uid=>{
      frags.push(`<div class="panel" style="margin-bottom:10px"><div style="display:flex;justify-content:space-between;align-items:center"><strong>${names[uid]||uid.slice(0,6)}</strong><span class="small" id="sum-${uid}">NHL ‚Äî</span></div><div class="sep"></div><div id="p-${uid}-nhl"></div></div>`);
    });
    box.innerHTML=frags.join('');
  }

  await pLimitAll(ids, 6, async (uid)=>{
    const t = await renderPickList(`p-${uid}-nhl`, uniqLimit(byUser.get(uid)||[]));
    const sumEl = $(`sum-${uid}`); if(sumEl) sumEl.textContent = `NHL ${Number(t||0).toFixed(2)}`;
  });
}

/* ---------- Badges UI (I/O-friendly, drop-in) ---------- */
async function refreshBadgesUI(){
  try{
    const grid = $('badgeGrid'); 
    if (!grid) return;
    if (!currentUser) return;

    const uid = currentUser.id;
    const CK  = `badges:${uid}`;
    const now = Date.now();

    // in-memory memo + inflight dedup
    const memo     = (window.__badgesMemo ||= new Map()); // uid -> {ids:Set,t}
    const inflight = (window.__badgesInflight ||= new Map());
    const TTL_MS   = 2 * 60 * 1000; // 2 minutes (badges don't change often)

    // helper to paint DOM with minimal work
    function paint(idsSet){
      const wanted = Array.from(idsSet).sort().join(',');
      if (grid._lastBadges === wanted) return; // no DOM work needed

      // Only touch elements that need changes
      const tiles = grid.querySelectorAll('.bTile');
      tiles.forEach(el=>{
        const id = el.getAttribute('data-badge');
        const shouldUnlock = id && idsSet.has(id);
        const hasClass = el.classList.contains('unlocked');
        if (shouldUnlock && !hasClass) el.classList.add('unlocked');
        else if (!shouldUnlock && hasClass) el.classList.remove('unlocked');
      });

      grid._lastBadges = wanted;
    }

    // 1) Fresh memo?
    const m = memo.get(uid);
    if (m && (now - m.t) < TTL_MS){
      paint(m.ids);
      return;
    }

    // 2) localStorage cache?
    const cached = getCache(CK); // expecting array of badge_ids
    if (cached && Array.isArray(cached)){
      const idsSet = new Set(cached.map(String));
      memo.set(uid, { ids: idsSet, t: now });
      paint(idsSet);
      // continue to step 3 only if you want to revalidate in background. We won't: saves I/O.
      return;
    }

    // 3) Dedup concurrent fetches
    if (inflight.has(uid)){
      const idsSet = await inflight.get(uid).catch(()=>null);
      if (idsSet) paint(idsSet);
      return;
    }

    // 4) Fetch once from Supabase
    const p = (async ()=>{
      const { data, error } = await supa
        .from('badge_events')
        .select('badge_id')
        .eq('user_id', uid);

      if (error || !data){
        // If we had an older memo, at least paint that; else do nothing.
        if (m) paint(m.ids);
        return null;
      }

      const idsArr = (data || []).map(r=>String(r.badge_id));
      const idsSet = new Set(idsArr);
      memo.set(uid, { ids: idsSet, t: now });
      setCache(CK, idsArr, TTL_MS);
      return idsSet;
    })();

    inflight.set(uid, p);
    const idsSet = await p;
    inflight.delete(uid);
    if (idsSet) paint(idsSet);

  }catch(e){ /* ignore */ }
}


/* ---------- Picks-left badge (I/O friendly) ---------- */
async function updatePicksLeft(){
  const el = $('picksLeft');
  if (!el) return;

  if (!currentUser) {
    el.textContent = 'Sign in to play';
    return;
  }

  // tiny memo to avoid re-fetching within a minute + inflight dedup
  const memo     = (window.__picksLeftMemo ||= new Map()); // uid -> {t,n,inf}
  const TTL_MS   = 60_000;
  const uid      = currentUser.id;
  const now      = Date.now();
  const hit      = memo.get(uid);

  // 1) Use cached value immediately if fresh
  if (hit && (now - hit.t) < TTL_MS) {
    el.textContent = `NHL ${Math.max(MAX_PICKS - hit.n, 0)} left`;
    return;
  }

  // 2) Show last known (stale) while we refresh
  if (hit) {
    el.textContent = `NHL ${Math.max(MAX_PICKS - hit.n, 0)} left`;
  } else {
    el.textContent = 'NHL ‚Äî left';
  }

  // 3) If a fetch is already running, piggyback
  if (hit && hit.inf) {
    try {
      const n = await hit.inf;
      el.textContent = `NHL ${Math.max(MAX_PICKS - n, 0)} left`;
    } catch {}
    return;
  }

  // 4) Fetch (uses picksForUser which has a 3 min TTL), then memoize
  const p = (async ()=>{
    try {
      const n = (await picksForUser(uid)).length;
      memo.set(uid, { t: Date.now(), n });
      return n;
    } catch {
      return hit ? hit.n : 0;
    }
  })();
  memo.set(uid, { ...(hit||{}), inf: p });

  try {
    const n = await p;
    el.textContent = `NHL ${Math.max(MAX_PICKS - n, 0)} left`;
  } finally {
    const cur = memo.get(uid);
    if (cur) memo.set(uid, { t: cur.t || Date.now(), n: cur.n }); // clear inf
  }
}

/* ---------- Tabs (render-on-activate, throttled) ---------- */
const tabs = {
  nhl:   { tab: $('tab-nhl'),    sec: $('sec-nhl')    },
  mine:  { tab: $('tab-mine'),   sec: $('sec-mine')   },
  lb:    { tab: $('tab-lb'),     sec: $('sec-lb')     },
  badges:{ tab: $('tab-badges'), sec: $('sec-badges') },
  rules: { tab: $('tab-rules'),  sec: $('sec-rules')  }
};

// throttle expensive renders to at most once per 60s per tab
const __tabLast = new Map();
const TAB_TTL_MS = 60_000;

function activateTab(k){
  Object.keys(tabs).forEach(x=>{
    const t = tabs[x]; if (!t.tab || !t.sec) return;
    t.tab.setAttribute('aria-selected', x===k ? 'true' : 'false');
    t.sec.classList.toggle('active', x===k);
  });

  const now = Date.now();
  const last = __tabLast.get(k) || 0;
  const fresh = (now - last) < TAB_TTL_MS;

  if (k === 'mine') {
    if (!fresh) { renderMyPicks(); __tabLast.set(k, now); }
  } else if (k === 'lb') {
    if (!fresh) { renderWeeklyBoards(); renderSeasonBoards(); __tabLast.set(k, now); }
  } else if (k === 'badges') {
    if (!fresh) { refreshBadgesUI(); __tabLast.set(k, now); }
  }
}

// wire once, with null checks
Object.keys(tabs).forEach(k=>{
  const t = tabs[k];
  if (t.tab) t.tab.addEventListener('click', ()=>activateTab(k));
});

(async ()=>{
  const { data:{ session:ses } } = await supa.auth.getSession();
  session = ses; 
  currentUser = session?.user || null;

  function showAuthUI(){
    const login   = document.getElementById('loginPwForm');
    const userBox = document.getElementById('userBox');
    const signupLink = document.querySelector('a[href="signup.html"]');

    if (currentUser){
      if (login)      login.style.display = 'none';
      if (signupLink) signupLink.style.display = 'none';
      if (userBox)    userBox.style.display = 'flex';
      const who = document.getElementById('whoami');
      if (who) who.textContent = currentUser.email || '(no email)';
    } else {
      if (login)      login.style.display = 'flex';
      if (signupLink) signupLink.style.display = 'inline-flex';
      if (userBox)    userBox.style.display = 'none';
    }
  }

  showAuthUI();

  if (currentUser) { 
    // one light read on first auth
    await loadOrCreatePlayer(); 
  }

  const league = NHL;
  await league.loadWeek();

  // Run non-critical UI fills in parallel (fewer round trips perceived)
  await Promise.allSettled([
    updatePicksLeft(),
    renderWeeklyBoards(),
    renderSeasonBoards(),
    currentUser ? renderMyPicks() : Promise.resolve(),
    refreshBadgesUI()
  ]);

  // ---- background refresh for boards (visible tab only) ----
  const BOARDS_MS = 180000; // 3 minutes
  let boardsTimer = null;

  function startBoardsTimer(){
    if (boardsTimer) return;
    boardsTimer = setInterval(()=>{
      if (document.hidden) return; // skip when not visible
      renderWeeklyBoards();
      renderSeasonBoards();
    }, BOARDS_MS);
  }
  function stopBoardsTimer(){
    if (boardsTimer){ clearInterval(boardsTimer); boardsTimer = null; }
  }
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden) stopBoardsTimer();
    else startBoardsTimer();
  });
  startBoardsTimer();

  // ---- auth changes (debounced to avoid double work) ----
  let authDebounce = null;
  supa.auth.onAuthStateChange((_event, sess)=>{
    if (authDebounce) clearTimeout(authDebounce);
    authDebounce = setTimeout(async ()=>{
      session = sess; 
      currentUser = session?.user || null;
      showAuthUI();

      if (currentUser){ await loadOrCreatePlayer(); }

      await Promise.allSettled([
        updatePicksLeft(),
        renderMyPicks(),
        renderWeeklyBoards(),
        refreshBadgesUI()
      ]);

      // mark picked tags on the grid without extra reads
      if (currentUser && NHL?.state?.events){
        const mine = await picksForUser(currentUser.id);
        mine.forEach(gid=>{
          const tag = $(`picked-${gid}`); if(tag) tag.style.display='inline-flex';
          const btn = document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none';
        });
      }
    }, 150); // small debounce
  });
})();

// Clean up channels + timers on page unload
window.addEventListener('beforeunload', () => {
  if (window.ST && Array.isArray(ST.chans)) {
    ST.chans.forEach(({ ch, timer }) => {
      try { ch.unsubscribe(); } catch {}
      if (timer) clearInterval(timer);
    });
  }
});

// === PERFORMANCE & CLEANUP PATCH ===

// 1) Clean up channels + timers on unload
window.addEventListener('beforeunload', () => {
  if (window.ST && ST.chans && ST.chans.forEach) {
    ST.chans.forEach(({ ch, timer }) => {
      try { ch.unsubscribe(); } catch {}
      if (timer) clearInterval(timer);
    });
  }
});

// 2) Pause polling when tab is hidden
(function () {
  if (!window.pollSince) return;
  const _pollSince = window.pollSince;
  window.pollSince = async function(room_id, listEl){
    if (document.hidden) return;   // skip when hidden
    return _pollSince(room_id, listEl);
  };
})();

// 3) Throttle polling per room (network-aware)
(function () {
  if (!window.pollSince) return;
  const _pollSince = window.pollSince;
  const lastRun = new Map();
  const conn = (navigator.connection || {});
  const GAP = ({
    'slow-2g': 20000, '2g': 20000, '3g': 15000, '4g': 10000
  }[conn.effectiveType]) || 12000;

  window.pollSince = async function(room_id, listEl){
    const now = Date.now();
    const prev = lastRun.get(room_id) || 0;
    if (now - prev < GAP) return;
    lastRun.set(room_id, now);
    return _pollSince(room_id, listEl);
  };
})();

// 4) Batch DOM appends for chat messages
(function () {
  if (!window.appendMsg) return;
  const _appendMsg = window.appendMsg;
  const queue = new Map();
  let scheduled = false;

  function flush() {
    scheduled = false;
    queue.forEach((items, listEl) => {
      const frag = document.createDocumentFragment();
      items.forEach(({m, meId}) => {
        const tmp = document.createElement('div');
        _appendMsg(tmp, m, meId);      // render into tmp
        while (tmp.firstChild) frag.appendChild(tmp.firstChild);
      });
      listEl.appendChild(frag);
      const nearBottom = (listEl.scrollHeight - listEl.scrollTop - listEl.clientHeight) < 60;
      if (nearBottom) listEl.scrollTop = listEl.scrollHeight;
    });
    queue.clear();
  }

  window.appendMsg = function(listEl, m, meId){
    const arr = queue.get(listEl) || [];
    arr.push({m, meId});
    queue.set(listEl, arr);
    if (!scheduled) {
      scheduled = true;
      (window.requestAnimationFrame || setTimeout)(flush);
    }
  };
})();
</script>
</body>
</html>



