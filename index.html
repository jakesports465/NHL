<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>NHL Puck'Em</title>
<style>
  /* ===== Theme Vars ===== */
  :root {
    --bg: #0b0d10;
    --surface: #12161b;
    --card: #171c23;
    --accent: #3c82f6;
    --muted: #8ea0b3;
    --text: #e8eef4;
    --border: #1b232d;
    --radius: 14px;
    --shadow: 0 4px 12px rgba(0,0,0,0.35);
  }

  /* ===== Base ===== */
  html,body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font: 15px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    -webkit-text-size-adjust: 100%;
    -webkit-tap-highlight-color: transparent;
  }
  *, *::before, *::after { box-sizing: border-box; }
  :focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 3px;
    border-radius: 8px;
  }

  /* ===== Header ===== */
  header {
    background: linear-gradient(to right, #101418, #141a21);
    border-bottom: 1px solid var(--border);
    position: sticky; top: 0; z-index: 50;
    display: flex; flex-wrap: wrap; gap: 12px;
    align-items: center; padding: 14px 16px;
    padding-top: calc(14px + env(safe-area-inset-top));
  }
  h1 {
    font-size: 20px; margin: 0; font-weight: 700;
    letter-spacing: -0.3px;
  }
  .sub { font-size: 13px; color: var(--muted); margin-left: 8px; }
  .pill {
    margin-left: auto;
    border-radius: 999px;
    padding: 4px 12px;
    font-size: 12px;
    background: #101722;
    border: 1px solid #2c3742;
  }
  .small { font-size: 12px; color: var(--muted); }

  /* ===== Tabs ===== */
  nav.tabs {
    display: flex; gap: 10px; padding: 8px 14px;
    background: #0f1318; border-bottom: 1px solid var(--border);
    position: sticky; top: 56px; z-index: 40;
    overflow-x: auto; scrollbar-width: none;
  }
  nav.tabs::-webkit-scrollbar { display: none; }
  .tab {
    background: #151b22;
    border: 1px solid #243241;
    border-radius: 10px;
    color: var(--text);
    font-size: 13px;
    padding: 10px 14px;
    cursor: pointer;
    transition: background .2s, transform .15s;
  }
  .tab:hover { background: #1c242e; transform: translateY(-1px); }
  .tab[aria-selected="true"] {
    background: #1d2a39;
    border-color: var(--accent);
    font-weight: 700;
    color: #fff;
  }

  /* ===== Layout ===== */
  main { max-width: 1180px; margin: 0 auto; padding: 18px; }
  .section { display: none; }
  .section.active { display: block; }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 16px;
    box-shadow: var(--shadow);
  }
  .panel {
    background: var(--card);
    border: 1px solid #1f2833;
    border-radius: 12px;
    padding: 12px;
  }
  .sep { height: 1px; background: var(--border); margin: 14px 0; }

  /* ===== Buttons / Inputs ===== */
  .btn {
    background: #1a2330;
    border: 1px solid #2a3a4d;
    color: var(--text);
    padding: 12px 14px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
    line-height: 1;
    min-height: 44px;
    transition: background .2s, transform .15s;
  }
  .btn:hover:not([disabled]) { background: #223042; transform: translateY(-1px); }
  .btn.small { padding: 10px 12px; font-size: 13px; min-height: 40px; }
  .btn[disabled] { opacity: .5; cursor: not-allowed; }
  input[type="text"], input[type="email"] {
    flex: 1;
    background: #0e141c;
    border: 1px solid #1f2a36;
    border-radius: 8px;
    color: var(--text);
    padding: 10px;
    font-size: 15px;
  }

  /* ===== Games Grid ===== */
  .gamesGrid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 14px;
  }
  .gameCard {
    background: var(--card);
    border: 1px solid #202a37;
    border-radius: 14px;
    overflow: hidden;
    box-shadow: var(--shadow);
    transition: transform .2s, box-shadow .2s;
  }
  .gameCard:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(0,0,0,0.5); }
  .band { height: 6px; }
  .gameBody { padding: 12px; }
  .teamsRow { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
  .team { display: flex; align-items: center; gap: 8px; min-width: 0; }
  .team img { width: 24px; height: 24px; border-radius: 6px; }
  .team .name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .scoreTag {
    padding: 2px 8px;
    border-radius: 6px;
    font-weight: 700;
    font-size: 13px;
    background: #101722;
    border: 1px solid #26313c;
  }
  .lockRow { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
  .pickedTag {
    display: inline-flex; align-items: center; gap: 6px;
    background: #0e1a14; color: #9be7b0;
    border: 1px solid #2e5e3f;
    border-radius: 999px;
    padding: 5px 10px;
    font-size: 12px;
    font-weight: 600;
  }

  /* ===== Leaderboard ===== */
  .lbRow {
    display: grid;
    grid-template-columns: auto 1fr auto auto;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border-radius: 10px;
    border: 1px solid #1e2833;
    background: #131a22;
    margin-bottom: 8px;
    transition: background .2s;
  }
  .lbRow:hover { background: #18212c; }
  .lbPos {
    width: 40px; text-align: center; font-weight: 900;
    border: 1px solid #26313c; border-radius: 8px; padding: 4px 0;
    background: #0f141a;
  }
  .lbTeam { display: flex; align-items: center; gap: 8px; min-width: 0; }
  .lbTeam img { width: 20px; height: 20px; border-radius: 4px; }
  .lbName { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .lbPts { font-weight: 700; }

  /* ===== Badges ===== */
  .badgeGrid { display: grid; grid-template-columns: repeat(auto-fill,minmax(170px,1fr)); gap: 14px; }
  .bTile {
    display: flex; gap: 12px; align-items: center;
    padding: 12px;
    border: 1px solid #1f2935;
    background: #111822;
    border-radius: 12px;
    transition: transform .2s, box-shadow .2s;
    opacity: .55; filter: grayscale(100%);
  }
  .bTile.unlocked { opacity: 1; filter: none; border-color: var(--accent); box-shadow: var(--shadow); }
  .bTile:hover { transform: translateY(-2px); }
  .bIcon {
    width: 42px; height: 42px;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px;
    border-radius: 10px;
    background: #0e141c;
  }
  .bMeta { display: flex; flex-direction: column; }
  .bMeta .nm { font-weight: 700; }
  .bMeta .lk { font-size: 12px; color: var(--muted); }

  /* ===== Tables (Fantasy Breakdown) ===== */
  .fTable { width: 100%; border-collapse: collapse; font-size: 13px; }
  .fTable th, .fTable td {
    border: 1px solid #1e2833;
    padding: 6px 8px;
  }
  .fTable th { background: #141b23; text-align: left; }
  .fTable tfoot td { font-weight: 700; }

  /* ===== Responsive ===== */
  @media(max-width: 720px) {
    h1 { font-size: 18px; }
    nav.tabs { top: 52px; }
    .lbRow { grid-template-columns: auto 1fr auto; }
  }
</style>
</head>
<body>

<!-- HEADER -->
<header>
  <h1>NHL Puck'Em <span class="sub">Every Mon–Sun · 5 picks</span></h1>
  <span id="picksLeft" class="pill">Sign in to play</span>
  <span class="small">Week: <b id="weekLabel">—</b></span>
  <div id="authBox" class="field" style="margin-left:auto;gap:6px">
    <form id="loginForm" class="field" style="gap:6px">
      <input id="emailInput" type="email" placeholder="your@email.com" required>
      <button class="btn small" type="submit">Send magic link</button>
    </form>
    <div id="userBox" class="field" style="display:none;gap:6px">
      <span class="small" id="whoami">—</span>
      <input id="displayNameInput" type="text" placeholder="Display name" style="max-width:160px">
      <button id="saveDisplayName" class="btn small" type="button">Save</button>
      <button id="logoutBtn" class="btn small" type="button">Sign out</button>
    </div>
  </div>
</header>

<!-- TABS -->
<nav class="tabs" role="tablist" aria-label="Sections">
  <button class="tab" id="tab-nhl" role="tab" aria-controls="sec-nhl" aria-selected="true">NHL</button>
  <button class="tab" id="tab-mine" role="tab" aria-controls="sec-mine">Picks</button>
  <button class="tab" id="tab-lb" role="tab" aria-controls="sec-lb">Leaderboards</button>
  <button class="tab" id="tab-badges" role="tab" aria-controls="sec-badges">Badges</button>
  <button class="tab" id="tab-rules" role="tab" aria-controls="sec-rules">Scoring</button>
</nav>

<!-- The rest of the sections (NHL, Picks, Leaderboards, Badges, Rules) stay as in your file;
     markup + JS unchanged, just inherits new styles -->
     
<!-- keep all your <section> blocks here (same IDs) ... -->

<!-- Your full JS logic remains identical -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
/* ---------- CONFIG ---------- */
const SUPA_URL  = 'https://acmqdokxwnkkjmfgfyhh.supabase.co';
const SUPA_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFjbXFkb2t4d25ra2ptZmdmeWhoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzMDY4MDAsImV4cCI6MjA3Mzg4MjgwMH0.cHgUbNwXQvWZJnQNetxO5kr0kVPIR2XO9vVkIJZj_-w';
const supa = supabase.createClient(SUPA_URL, SUPA_ANON, {
  auth: { persistSession: true, detectSessionInUrl: true, flowType: 'pkce' }
});

/* ---------- PERF: caches + dedup + parallel limiter (unchanged) ---------- */
const TZ='America/Chicago';
const MAX_PICKS=5;
const $ = id => document.getElementById(id);

const PERF_NS = `hf:${new Date().toISOString().slice(0,10)}`;
const L1 = new Map();
function k(ns){ return `${PERF_NS}:${ns}`; }
function getCache(ns){
  const key=k(ns);
  if(L1.has(key)) return L1.get(key);
  try{
    const raw=localStorage.getItem(key);
    if(!raw) return null;
    const obj=JSON.parse(raw);
    if(obj.exp && Date.now()>obj.exp){ localStorage.removeItem(key); return null; }
    L1.set(key,obj.val);
    return obj.val;
  }catch{ return null; }
}
function setCache(ns,val,ttlMs){
  const key=k(ns);
  L1.set(key,val);
  try{ localStorage.setItem(key, JSON.stringify({val,exp: ttlMs?Date.now()+ttlMs:null})); }catch{}
}
function delCache(ns){ try{ localStorage.removeItem(k(ns)); }catch{} L1.delete(k(ns)); }

const INFLIGHT = new Map();
async function dedupFetch(url){
  if(INFLIGHT.has(url)) return INFLIGHT.get(url);
  const p = fetch(url,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(r.status); return r.json(); })
    .finally(()=>INFLIGHT.delete(url));
  INFLIGHT.set(url,p);
  return p;
}
async function safeJson(url,retries=2){
  for(let i=0;i<=retries;i++){
    try{ return await dedupFetch(url); }
    catch(e){ if(i===retries) throw e; await new Promise(r=>setTimeout(r,500*(i+1))); }
  }
}
async function pLimitAll(items, limit, worker){
  const out=new Array(items.length); let i=0, active=0;
  return await new Promise(resolve=>{
    const pump=()=>{
      while(active<limit && i<items.length){
        const idx=i++; active++;
        Promise.resolve(worker(items[idx],idx))
          .then(v=>{ out[idx]=v; })
          .catch(()=>{ out[idx]=undefined; })
          .finally(()=>{ active--; (i>=items.length && active===0)?resolve(out):pump(); });
      }
    };
    pump();
  });
}

/* ---------- Helpers & week logic (Mon 08:00 CT) ---------- */
function nowCT(){ return new Date(new Date().toLocaleString('en-US',{timeZone:TZ})); }
function addDaysCT(d,days){ const n=new Date(d.getTime()); n.setDate(n.getDate()+days); return new Date(n.toLocaleString('en-US',{timeZone:TZ})); }
function parts(d,opts){ const p=new Intl.DateTimeFormat('en-US',opts).formatToParts(d); const o={}; p.forEach(x=>o[x.type]=x.value); return o; }

/* Week anchor = Monday 08:00 CT */
function weekKey(){
  const n=nowCT();
  const wd=n.getDay();
  const daysSinceMon=(wd-1+7)%7;
  const mon=addDaysCT(n,-daysSinceMon);
  const hour=Number(parts(n,{hour:'2-digit',hour12:false}).hour);
  const after8 = hour>=8 || daysSinceMon>0;
  const anchor = after8? mon : addDaysCT(mon,-7);
  const p=parts(anchor,{year:'numeric',month:'2-digit',day:'2-digit'});
  return `${p.year}-${p.month}-${p.day}-Mon08CT`;
}
function weekDates(){
  const n=nowCT();
  const wd=n.getDay();
  const daysSinceMon=(wd-1+7)%7;
  const mon=addDaysCT(n,-daysSinceMon);
  const list=[];
  for(let i=0;i<7;i++){
    const d=addDaysCT(mon,i);
    const p=parts(d,{year:'numeric',month:'2-digit',day:'2-digit'});
    list.push(`${p.year}-${p.month}-${p.day}`);
  }
  const pM=parts(mon,{month:'2-digit',day:'2-digit'});
  const pS=parts(addDaysCT(mon,6),{month:'2-digit',day:'2-digit'});
  return {list,start:list[0],end:list[6],pretty:`${pM.month}/${pM.day} → ${pS.month}/${pS.day}`};
}
const WEEK_KEY=weekKey(); const WEEK=weekDates();
$('weekLabel').textContent=WEEK.pretty; $('lbWeekLabel').textContent=`Week: ${WEEK.pretty}`; $('mineWeekLabel').textContent=WEEK.pretty;

/* ---------- ESPN helpers ---------- */
function cdnNHL(t){ if(!t) return null; if(t.logos?.[0]?.href) return String(t.logos[0].href).replace(/^http:/,'https:'); if(t.abbreviation) return `https://a.espncdn.com/i/teamlogos/nhl/500/${t.abbreviation}.png`; return null; }

/* ---------- Supabase helpers (auth + players) ---------- */
let session=null, currentUser=null, displayName='';
function toast(msg){ const t=document.createElement('div'); t.textContent=msg; Object.assign(t.style,{position:'fixed',right:'16px',bottom:'16px',background:'#0f1318',border:'1px solid #264',padding:'8px 10px',borderRadius:'10px',zIndex:50}); document.body.appendChild(t); setTimeout(()=>t.remove(),1600); }

async function loadOrCreatePlayer(){
  if(!currentUser) return;
  const uid=currentUser.id;
  const { data, error } = await supa.from('players').select('*').eq('id',uid).maybeSingle();
  if(error){ console.error(error); return; }
  if(!data){
    const def = (currentUser.email||'user').split('@')[0];
    const { error:insErr } = await supa.from('players').insert({ id:uid, display_name:def });
    if(insErr){ console.error(insErr); }
    displayName=def;
  }else{
    displayName=data.display_name||'';
  }
  $('displayNameInput').value=displayName||'';
}

$('saveDisplayName').addEventListener('click', async ()=>{
  if(!currentUser) return;
  const name = ($('displayNameInput').value||'').trim();
  if(!name) return;
  const { error } = await supa.from('players').upsert({ id: currentUser.id, display_name: name });
  if(!error){ displayName=name; toast('Saved ✓'); renderWeeklyBoards(); renderSeasonBoards(); }
});

$('logoutBtn').addEventListener('click', async ()=>{ await supa.auth.signOut(); location.reload(); });

$('loginForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const email=$('emailInput').value.trim();
  if(!email) return;
  const redirectTo = window.location.href;
  const { error } = await supa.auth.signInWithOtp({ email, options:{emailRedirectTo: redirectTo, shouldCreateUser:true } });
  if(error){ alert(error.message); return; }
  toast('Magic link sent! Check your email.');
});

/* ---------- Picks (Supabase) ---------- */
function uniqLimit(arr){ const out=[]; const seen=new Set(); (arr||[]).forEach(x=>{ const id=String(x); if(!seen.has(id)){ seen.add(id); out.push(id); } }); return out.slice(0,MAX_PICKS); }
const CK_MY = uid => `picks:${WEEK_KEY}:${uid}`;
const CK_ALL = `allpicks:${WEEK_KEY}`;
const NAME_MEMO = new Map();

async function picksForUser(uid){
  const ck = CK_MY(uid);
  const cached = getCache(ck);
  if(cached) return cached;
  const { data, error } = await supa.from('picks')
    .select('game_id')
    .eq('user_id', uid)
    .eq('league','NHL')
    .eq('week_key', WEEK_KEY);
  const list = error ? [] : uniqLimit((data||[]).map(r=>String(r.game_id)));
  setCache(ck, list, 15000);
  return list;
}
async function setPick(uid, gameId){
  const { error } = await supa.from('picks').upsert(
    [{ user_id: uid, league:'NHL', week_key: WEEK_KEY, game_id: String(gameId) }],
    { onConflict: 'user_id,league,week_key,game_id' }
  );
  if(error){ alert(error.message); return false; }
  delCache(CK_MY(uid)); delCache(CK_ALL);
  refreshBadgesUI().catch(()=>{});
  return true;
}
async function allPicksThisWeek(){
  const cached = getCache(CK_ALL);
  if(cached) return cached;
  const { data, error } = await supa.from('picks')
    .select('user_id, game_id')
    .eq('league','NHL')
    .eq('week_key',WEEK_KEY);
  const rows = error ? [] : (data||[]);
  setCache(CK_ALL, rows, 20000);
  return rows;
}
async function getDisplayNames(userIds){
  const ids = [...new Set(userIds||[])].filter(Boolean);
  if(ids.length===0) return {};
  const need = ids.filter(id=>!NAME_MEMO.has(id));
  if(need.length){
    const { data, error } = await supa.from('players')
      .select('id,display_name')
      .in('id', need);
    if(!error && data){
      data.forEach(r=>NAME_MEMO.set(r.id, r.display_name || r.id.slice(0,6)));
      need.forEach(id=>{ if(!NAME_MEMO.has(id)) NAME_MEMO.set(id, id.slice(0,6)); });
    }else{
      need.forEach(id=>NAME_MEMO.set(id, id.slice(0,6)));
    }
  }
  const map={}; ids.forEach(id=>map[id]=NAME_MEMO.get(id));
  return map;
}

/* ---------- NEW: Push ESPN summaries into SQL and read from DB ---------- */
async function pushSummaryToSQL(gameId, summaryJson){
  // Calls SECURITY DEFINER SQL to compute + update game_scores, weekly_results, season_points
  const { error } = await supa.rpc('upsert_nhl_game_from_summary', {
    p_week_key: WEEK_KEY,
    p_game_id: String(gameId),
    p_summary: summaryJson
  });
  if(error){ console.error('upsert_nhl_game_from_summary failed:', error.message); }
}

/* === Modified: include stat fields for breakdown === */
async function getGameScoreFromDB(gid){
  const { data, error } = await supa
    .from('game_scores')
    .select('total,home_pts,away_pts,close_bonus,ot_bonus,so_bonus,is_final,goals,ppg,shg,shots,saves,hits,blocks,pim')
    .eq('league','NHL')
    .eq('week_key',WEEK_KEY)
    .eq('game_id', String(gid))
    .maybeSingle();
  if(error || !data) return null;
  return data;
}

/* ---------- League (NHL) UI ---------- */
function leagueFactory(){
  const st={ events:[], selected:null, poll:null, gameRows:[] };
  const dom={ gridCard:$('nhl-gridCard'), note:$('nhl-note'), grid:$('nhl-grid'), top:$('nhl-top'), back:$('nhl-back'), add:$('nhl-addPick'), live:$('nhl-liveHeader'), teamSide:$('nhl-teamSide'), fscore:$('nhl-fscore'), bonus:$('nhl-bonuses'), clock:$('nhl-clock'), q:$('nhl-q'), state:$('nhl-state'), log:$('nhl-log'), gameLB:$('nhl-gameLB'), userLB:$('nhl-userLB') };
  const api={ scoreboard:(d)=>`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard?dates=${d.replace(/-/g,'')}`, summary:(id)=>`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/summary?event=${id}` };

  dom.back.addEventListener('click', ()=>{ dom.top.style.display='none'; dom.gridCard.style.display='block'; st.selected=null; });
  dom.add.addEventListener('click', async ()=>{
    if(!currentUser){ alert('Sign in first.'); return; }
    if(!st.selected) return;
    const kick=new Date(st.selected.start).getTime();
    if(Date.now()>=kick){ alert('Locked (already started)'); return; }
    const myList = await picksForUser(currentUser.id);
    const gid=String(st.selected.id);
    if(myList.includes(gid)){ alert('Already picked.'); return; }
    if(myList.length>=MAX_PICKS){ alert(`You already have ${MAX_PICKS} picks in NHL.`); return; }
    const ok = await setPick(currentUser.id,gid);
    if(ok){
      updatePicksLeft();
      renderWeeklyBoards();
      renderMyPicks();
      const tag=$(`picked-${st.selected.id}`); if(tag) tag.style.display='inline-flex';
      const btn=document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none';
      toast('Pick saved ✓');
    }
  });

  function renderGrid(){
    dom.grid.innerHTML='';
    (st.events||[]).forEach(g=>{
      const started=Date.now()>=new Date(g.start).getTime();
      const card=document.createElement('div');
      card.className='gameCard';
      const puck=new Date(g.start).toLocaleString([], {weekday:'short',month:'short',day:'numeric',hour:'numeric',minute:'2-digit'});
      card.innerHTML=`
        <div class="band" style="background:linear-gradient(90deg, ${g.away.color?('#'+g.away.color):'#1a232d'} 0%, ${g.home.color?('#'+g.home.color):'#26313c'} 100%)"></div>
        <div class="gameBody">
          <div class="teamsRow">
            <div class="team">${g.away.logo?`<img src="${g.away.logo}" alt="">`:``}<div class="name">${g.away.name}</div><span class="scoreTag" id="NHL-a-${g.id}">0</span></div>
            <div class="small" style="opacity:.8">@</div>
            <div class="team" style="justify-content:flex-end">${g.home.logo?`<img src="${g.home.logo}" alt="">`:``}<div class="name">${g.home.name}</div><span class="scoreTag" id="NHL-h-${g.id}">0</span></div>
          </div>
          <div class="small" style="margin-top:6px;opacity:.9">Score: <span id="NHL-scr-${g.id}">—</span> · <span id="NHL-st-${g.id}">pre</span> · Puck drop: ${puck}</div>
          <div class="lockRow">
            <span class="pickedTag" style="display:none" id="picked-${g.id}">✓ Picked</span>
            <button class="btn pickBtn" data-gid="${g.id}" ${started?'style="display:none"':''}>Add to my picks</button>
            <button class="btn small viewBtn">Open</button>
          </div>
          ${started?'<div class="small" style="color:#c78;margin-top:6px">Locked (already started)</div>' : ''}
        </div>`;
      card.querySelector('.viewBtn').addEventListener('click',()=>openGame(g));
      const pickBtn=card.querySelector('.pickBtn');
      if(pickBtn){
        pickBtn.addEventListener('click', async ()=>{
          if(!currentUser){ alert('Sign in first.'); return; }
          if(Date.now()>=new Date(g.start).getTime()){ alert('Locked (already started)'); return; }
          const myList = await picksForUser(currentUser.id);
          const gid=String(g.id);
          if(myList.includes(gid)){ alert('Already picked.'); return; }
          if(myList.length>=MAX_PICKS){ alert(`You already have ${MAX_PICKS} picks in NHL.`); return; }
          const ok = await setPick(currentUser.id,gid);
          if(ok){
            updatePicksLeft();
            renderWeeklyBoards();
            renderMyPicks();
            const tag=$(`picked-${g.id}`); if(tag) tag.style.display='inline-flex';
            pickBtn.style.display='none';
            toast('Pick saved ✓');
          }
        });
      }
      dom.grid.appendChild(card);
    });
  }

  async function refreshGridScores(){
    const evs = st.events||[]; if(!evs.length) return;
    const rows = await pLimitAll(evs, 6, async (g)=>{
      try{
        const s=await safeJson(api.summary(g.id));
        // push into SQL (math happens server-side)
        await pushSummaryToSQL(g.id, s);
        // read final/rolling fantasy total + box score from DB
        const row = await getGameScoreFromDB(g.id);
        const comp=s?.header?.competitions?.[0]||{};
        let homeC=null,awayC=null; (comp.competitors||[]).forEach(c=>{ if(c.homeAway==='home') homeC=c; if(c.homeAway==='away') awayC=c; });
        return {
          id:g.id,
          awayPts: row?.away_pts ?? Number(awayC?.score??0),
          homePts: row?.home_pts ?? Number(homeC?.score??0),
          score: row?.total ?? 0,
          status:(comp.status?.type?.shortDetail||comp.status?.type?.description||'—')
        };
      }catch{ return null; }
    });
    const valid=rows.filter(Boolean);
    for(const r of valid){
      const scEl=$(`NHL-scr-${r.id}`), stEl=$(`NHL-st-${r.id}`), aEl=$(`NHL-a-${r.id}`), hEl=$(`NHL-h-${r.id}`);
      if(scEl) scEl.textContent=`${r.awayPts}–${r.homePts}`;
      if(stEl) stEl.textContent=r.status||'—';
      if(aEl) aEl.textContent=r.awayPts;
      if(hEl) hEl.textContent=r.homePts;
    }
    st.gameRows = evs.map(g=>{
      const r = valid.find(x=>x && String(x.id)===String(g.id));
      if(!r) return null;
      return { id:g.id, awayName:g.away.name, homeName:g.home.name, awayLogo:g.away.logo, homeLogo:g.home.logo, score:r.score, status:r.status };
    }).filter(Boolean).sort((a,b)=>b.score-a.score);
    renderGameLB();
    renderUserLB();
  }

  function renderGameLB(){
    if(!st.gameRows) return;
    const tgt=$('nhl-gameLB');
    if(!tgt) return;
    tgt.innerHTML = st.gameRows.slice(0,15).map(r=>{
      return `<div class="lbRow">
        <div class="lbTeam">${r.awayLogo?`<img src="${r.awayLogo}" alt="">`:''}<span class="lbName" style="max-width:280px">${r.awayName} @ ${r.homeName}</span>${r.homeLogo?`<img src="${r.homeLogo}" alt="" style="margin-left:6px">`:''}</div>
        <div class="lbPts">${Number(r.score||0).toFixed(2)}</div>
        <div class="small">${r.status||''}</div>
      </div>`;
    }).join('');
  }

  function openGame(g){
    st.selected=g;
    $('nhl-top').setAttribute('data-show','true');
    dom.live.textContent=`${g.away.name} @ ${g.home.name}`;
    dom.teamSide.innerHTML=
      `<div class="teamline" style="border-left:6px solid ${g.away.color?('#'+g.away.color):'#2a3643'}">
         <div style="display:flex;gap:10px;align-items:center">${g.away.logo?`<img src="${g.away.logo}" alt="">`:''}<div style="font-weight:700">${g.away.name}</div></div>
         <div id="NHL-awayScore" style="font-weight:800">—</div>
       </div>
       <div class="teamline" style="border-left:6px solid ${g.home.color?('#'+g.home.color):'#2a3643'}">
         <div style="display:flex;gap:10px;align-items:center">${g.home.logo?`<img src="${g.home.logo}" alt="">`:''}<div style="font-weight:700">${g.home.name}</div></div>
         <div id="NHL-homeScore" style="font-weight:800">—</div>
       </div>`;
    dom.gridCard.style.display='none'; dom.top.style.display='block';
    updateGameOnce(); if(st.poll) clearInterval(st.poll); st.poll=setInterval(updateGameOnce,20000);
    renderGameLB(); renderUserLB();
  }

  /* === Added: render breakdown helper === */
  function renderBreakdown(row){
    const W = { goal:4, ppg:1.5, shg:1.0, sog:0.1, sv:0.05, hit:0.05, block:0.05, pim:-0.1, close:4, ot:2, so:2 };
    const safe = n => Number(n||0);
    const items = [
      { label:'Goals',         count:safe(row.goals),  per:W.goal,  pts:safe(row.goals)*W.goal },
      { label:'PowerPlay Goals',  count:safe(row.ppg),    per:W.ppg,   pts:safe(row.ppg)*W.ppg },
      { label:'Shorthanded Goals',count:safe(row.shg),    per:W.shg,   pts:safe(row.shg)*W.shg },
      { label:'Shots on Goal', count:safe(row.shots),  per:W.sog,   pts:safe(row.shots)*W.sog },
      { label:'Saves',         count:safe(row.saves),  per:W.sv,    pts:safe(row.saves)*W.sv },
      { label:'Hits',          count:safe(row.hits),   per:W.hit,   pts:safe(row.hits)*W.hit },
      { label:'Blocked Shots', count:safe(row.blocks), per:W.block, pts:safe(row.blocks)*W.block },
      { label:'Penalty Minutes',count:safe(row.pim),   per:W.pim,   pts:safe(row.pim)*W.pim },
    ];
    const tbody = document.querySelector('#nhl-breakdown tbody');
    if(!tbody) return;
    tbody.innerHTML = items.map(it=>`
      <tr>
        <td>${it.label}</td>
        <td>${it.count}</td>
        <td>${it.per.toFixed(2)}</td>
        <td>${it.pts.toFixed(2)}</td>
      </tr>
    `).join('');

    const bonus = safe(row.close_bonus)+safe(row.ot_bonus)+safe(row.so_bonus);
    const offenseDefense = items.reduce((s,x)=>s+x.pts,0);
    const total = offenseDefense + bonus;

    const bdBonuses = document.getElementById('bd-bonuses');
    const bdTotal = document.getElementById('bd-total');
    if(bdBonuses) bdBonuses.textContent = bonus.toFixed(2);
    if(bdTotal) bdTotal.textContent = (row?.total!=null ? Number(row.total).toFixed(2) : total.toFixed(2));

    // Also reflect bonuses line up top
    const cb = safe(row.close_bonus), ob=safe(row.ot_bonus), sb=safe(row.so_bonus);
    document.getElementById('nhl-bonuses').textContent =
      `Bonuses: ${cb?`Close +${cb}`:'—'} · ${ob?`OT +${ob}`:'—'} · ${sb?`SO +${sb}`:'—'}`;
  }

  async function updateGameOnce(){
    if(!st.selected) return; const id=st.selected.id;
    try{
      const s=await safeJson(api.summary(id));
      const comp=s?.header?.competitions||[];
      const c0=(comp[0]||{}); const status=c0.status||{};
      let homeC=null,awayC=null; (c0.competitors||[]).forEach(c=>{ if(c.homeAway==='home') homeC=c; if(c.homeAway==='away') awayC=c; });

      // push into SQL (math server-side), then read from DB
      await pushSummaryToSQL(id, s);
      const row = await getGameScoreFromDB(id);

      $('NHL-homeScore').textContent=String(row?.home_pts ?? homeC?.score ?? 0);
      $('NHL-awayScore').textContent=String(row?.away_pts ?? awayC?.score ?? 0);
      $('nhl-clock').textContent=status.displayClock||'—';
      $('nhl-q').textContent=String(status.period??'—');
      $('nhl-state').textContent=(status.type?.description||status.type?.shortDetail||'—');

      $('nhl-fscore').textContent = (row?.total!=null ? Number(row.total).toFixed(2) : '—');

      // === Added: fill Fantasy Breakdown table
      if(row) renderBreakdown(row);

      const sps=s?.scoringPlays||[];
      if(!document.getElementById('nhl-log')){
        const log = document.createElement('div'); log.id='nhl-log'; log.className='log'; document.querySelector('#nhl-top').appendChild(log);
      }
      const logBox=document.getElementById('nhl-log'); logBox.innerHTML='';
      for(const sp of sps.slice(-10).reverse()){
        const t=(sp.clock?.displayValue||''), q=(sp.period?.number?'P'+sp.period.number:''), d=(sp.text||sp.description||'');
        const div=document.createElement('div'); div.textContent=`[${q} ${t}] ${d}`; logBox.appendChild(div);
      }
    }catch(e){ /* ignore */ }
  }

  async function loadWeek(){
    dom.note.textContent=`Loading NHL games for ${WEEK.start} → ${WEEK.end} …`;
    const all=[];
    for(const d of WEEK.list){
      const sb=await safeJson(api.scoreboard(d)).catch(()=>null);
      const evs=sb?.events||[];
      for(const ev of evs){
        const c=ev.competitions?.[0]||{};
        let home=null,away=null; (c.competitors||[]).forEach(x=>{ if(x.homeAway==='home') home=x; if(x.homeAway==='away') away=x; });
        all.push({
          id:ev.id,
          start:ev.date,
          home:{ name:home?.team?(home.team.shortDisplayName||home.team.displayName):'Home', color:home?.team?.color||null, logo:cdnNHL(home?.team||null) },
          away:{ name:away?.team?(away.team.shortDisplayName||away.team.displayName):'Away', color:away?.team?.color||null, logo:cdnNHL(away?.team||null) }
        });
      }
    }
    all.sort((a,b)=>new Date(a.start)-new Date(b.start));
    st.events=all;
    dom.note.textContent=`${all.length} games`;
    renderGrid();
    if(currentUser){
      const mine = await picksForUser(currentUser.id);
      mine.forEach(gid=>{ const tag=$(`picked-${gid}`); if(tag) tag.style.display='inline-flex'; const btn=document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none'; });
    }
    refreshGridScores();
    setInterval(refreshGridScores,30000);
  }

  function renderUserLB(){
    // Left intentionally minimal; main weekly leaderboard lives in Leaderboards tab.
  }

  return { loadWeek, state:st };
}
const NHL = leagueFactory();

/* ---------- DB-driven helpers for boards/picks ---------- */
function ordinal(n){ const s=["th","st","nd","rd"], v=n%100; return n+ (s[(v-20)%10]||s[v]||s[0]); }

async function renderWeeklyBoards(){
  const box=$('lbNHLWeek');
  if(!box) return;
  box.innerHTML='<div class="small">Loading…</div>';
  const { data, error } = await supa.from('weekly_results')
    .select('user_id,total,rank')
    .eq('league','NHL')
    .eq('week_key',WEEK_KEY)
    .order('rank');
  if(error){ console.error(error); box.innerHTML='<div class="small">Error.</div>'; return; }
  if(!data || !data.length){ box.innerHTML='<div class="small">No results yet.</div>'; return; }
  const names=await getDisplayNames(data.map(r=>r.user_id));
  box.innerHTML='';
  data.forEach(r=>{
    const div=document.createElement('div'); div.className='lbRow';
    div.innerHTML=`<span class="lbPos">${r.rank}</span><div class="lbTeam"><span class="lbName">${names[r.user_id]||r.user_id.slice(0,6)}</span></div><div class="lbPts">${Number(r.total).toFixed(2)}</div><div class="small">Weekly</div>`;
    box.appendChild(div);
  });
}

async function renderSeasonBoards(){
  const box=$('lbNHLSeason'); if(!box) return;
  box.innerHTML='<div class="small">Loading…</div>';
  const { data, error } = await supa.from('season_points')
    .select('user_id, points')
    .eq('league','NHL')
    .order('points', { ascending:false });
  if(error){ console.error(error); box.innerHTML='<div class="small">Error.</div>'; return; }
  if(!data || !data.length){ box.innerHTML='<div class="small">No season data yet.</div>'; return; }
  const names=await getDisplayNames(data.map(r=>r.user_id));
  box.innerHTML='';
  data.forEach((r,i)=>{
    const div=document.createElement('div'); div.className='lbRow';
    div.innerHTML=`<span class="lbPos">${i+1}</span><div class="lbTeam"><span class="lbName">${names[r.user_id]||r.user_id.slice(0,6)}</span></div><div class="lbPts">${r.points}</div><div class="small">Season</div>`;
    box.appendChild(div);
  });
}

/* ---------- My Picks (reads game_scores for per-game totals) ---------- */
const RENDER_TICKETS = new Map();
function nextTicket(key){ const n=(RENDER_TICKETS.get(key)||0)+1; RENDER_TICKETS.set(key,n); return n; }
function isCurrent(key,t){ return RENDER_TICKETS.get(key)===t; }
let LAST_ALL_IDS_JSON = '';

function gameRowHTML(meta,score){
  return `<div class="lbTeam">${meta.awayLogo?`<img src="${meta.awayLogo}" alt="">`:''}<span class="lbName" style="max-width:280px">${meta.awayName} @ ${meta.homeName}</span>${meta.homeLogo?`<img src="${meta.homeLogo}" alt="" style="margin-left:6px">`:''}</div><div class="lbPts">${Number(score||0).toFixed(2)}</div><div class="small">Game</div>`;
}
async function gameMeta(gid){
  const ck=`meta:${gid}`;
  const c=getCache(ck);
  if(c) return c;
  const ev=NHL.state.events.find(e=>String(e.id)===String(gid));
  if(ev){
    const m={awayName:ev.away.name,homeName:ev.home.name,awayLogo:ev.away.logo,homeLogo:ev.home.logo};
    setCache(ck,m,24*60*60*1000);
    return m;
  }
  try{
    const s=await safeJson(`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/summary?event=${gid}`);
    const comp=s?.header?.competitions?.[0]||{}; let home=null,away=null; (comp.competitors||[]).forEach(x=>{ if(x.homeAway==='home') home=x; if(x.homeAway==='away') away=x; });
    const m={ awayName:away?.team?(away.team.shortDisplayName||away.team.displayName):'Away', homeName:home?.team?(home.team.shortDisplayName||home.team.displayName):'Home', awayLogo:cdnNHL(away?.team||null), homeLogo:cdnNHL(home?.team||null) };
    setCache(ck,m,24*60*60*1000);
    return m;
  }catch{ return {awayName:'Away',homeName:'Home',awayLogo:null,homeLogo:null}; }
}
async function renderPickList(containerId, gidList){
  const el=$(containerId);
  const myTicket = nextTicket(containerId);
  const clean=uniqLimit(gidList||[]);
  el.innerHTML='';
  if(clean.length===0){
    if(isCurrent(containerId,myTicket)) el.innerHTML='<div class="small">No picks yet.</div>';
    return 0;
  }
  const results = await pLimitAll(clean, 6, async (gid)=>{
    // Ensure SQL has the latest by fetching ESPN summary -> upsert -> then read DB score
    try{
      const s=await safeJson(`https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/summary?event=${gid}`);
      await pushSummaryToSQL(gid, s);
    }catch{}
    const [meta,row] = await Promise.all([gameMeta(gid), getGameScoreFromDB(gid)]);
    return {meta,score:row?.total||0};
  });
  if(!isCurrent(containerId,myTicket)) return 0;
  let total=0; const rows=[];
  for(const r of results){ total+=r.score; rows.push(`<div class="lbRow">${gameRowHTML(r.meta,r.score)}</div>`); }
  el.innerHTML=rows.join('');
  return total;
}
async function renderMyPicks(){
  if(!currentUser){ $('myNHL').innerHTML='<div class="small">Sign in to see your picks.</div>'; $('allPicks').innerHTML='<div class="small">Sign in to see everyone.</div>'; return; }
  const myList = await picksForUser(currentUser.id);
  const tot = await renderPickList('myNHL', myList);
  $('myNHLTotal').textContent = Number(tot||0).toFixed(2);

  const box=$('allPicks');
  const rows = await allPicksThisWeek();
  const byUser=new Map(); rows.forEach(r=>{ const a=byUser.get(r.user_id)||[]; a.push(String(r.game_id)); byUser.set(r.user_id,a); });
  const ids=[...byUser.keys()];
  if(!ids.length){ box.innerHTML='<div class="small">No picks yet.</div>'; return; }

  const idsJson = JSON.stringify(ids.slice().sort());
  if(idsJson !== LAST_ALL_IDS_JSON){
    LAST_ALL_IDS_JSON = idsJson;
    const names=await getDisplayNames(ids);
    const frags=[]; ids.forEach(uid=>{
      frags.push(`<div class="panel" style="margin-bottom:10px"><div style="display:flex;justify-content:space-between;align-items:center"><strong>${names[uid]||uid.slice(0,6)}</strong><span class="small" id="sum-${uid}">NHL —</span></div><div class="sep"></div><div id="p-${uid}-nhl"></div></div>`);
    });
    box.innerHTML=frags.join('');
  }

  await pLimitAll(ids, 6, async (uid)=>{
    const t = await renderPickList(`p-${uid}-nhl`, uniqLimit(byUser.get(uid)||[]));
    const sumEl = $(`sum-${uid}`); if(sumEl) sumEl.textContent = `NHL ${Number(t||0).toFixed(2)}`;
  });
}

/* ---------- Badges UI (unchanged; auto based on DB) ---------- */
async function refreshBadgesUI(){
  try{
    const grid = $('badgeGrid'); if(!grid) return;
    grid.querySelectorAll('.bTile').forEach(el=>el.classList.remove('unlocked'));
    if(!currentUser) return;
    const { data, error } = await supa
      .from('badge_events')
      .select('badge_id')
      .eq('user_id', currentUser.id);
    if(error || !data) return;
    const got = new Set(data.map(r=>r.badge_id));
    grid.querySelectorAll('.bTile').forEach(el=>{
      const id = el.getAttribute('data-badge');
      if(id && got.has(id)) el.classList.add('unlocked');
    });
  }catch(e){ /* ignore */ }
}

/* ---------- Picks-left badge ---------- */
async function updatePicksLeft(){
  if(!currentUser){ $('picksLeft').textContent='Sign in to play'; return; }
  const n=(await picksForUser(currentUser.id)).length;
  $('picksLeft').textContent=`NHL ${Math.max(MAX_PICKS-n,0)} left`;
}

/* ---------- Tabs ---------- */
const tabs={ nhl:{tab:$('tab-nhl'),sec:$('sec-nhl')}, mine:{tab:$('tab-mine'),sec:$('sec-mine')}, lb:{tab:$('tab-lb'),sec:$('sec-lb')}, badges:{tab:$('tab-badges'),sec:$('sec-badges')}, rules:{tab:$('tab-rules'),sec:$('sec-rules')} };
Object.keys(tabs).forEach(k=>tabs[k].tab.addEventListener('click',()=>{ Object.keys(tabs).forEach(x=>{ tabs[x].tab.setAttribute('aria-selected', x===k?'true':'false'); tabs[x].sec.classList.toggle('active', x===k); }); if(k==='mine') renderMyPicks(); if(k==='lb'){ renderWeeklyBoards(); renderSeasonBoards(); } if(k==='badges'){ refreshBadgesUI(); }}));

/* ---------- Boot ---------- */
(async ()=>{
  const { data:{ session:ses } } = await supa.auth.getSession();
  session=ses; currentUser = session?.user || null;

  function showAuthUI(){
    if(currentUser){
      $('loginForm').style.display='none';
      $('userBox').style.display='flex';
      $('whoami').textContent = currentUser.email || '(no email)';
    }else{
      $('loginForm').style.display='flex';
      $('userBox').style.display='none';
    }
  }
  showAuthUI();

  if(currentUser){ await loadOrCreatePlayer(); }

  const league = NHL; await league.loadWeek();
  await updatePicksLeft();
  await renderWeeklyBoards();
  await renderSeasonBoards();
  await renderMyPicks();
  await refreshBadgesUI();

  supa.auth.onAuthStateChange(async (_event, sess)=>{
    session=sess; currentUser=session?.user||null; showAuthUI();
    if(currentUser){ await loadOrCreatePlayer(); }
    await updatePicksLeft();
    await renderMyPicks();
    await renderWeeklyBoards();
    if(currentUser && NHL?.state?.events){
      const mine = await picksForUser(currentUser.id);
      mine.forEach(gid=>{ const tag=$(`picked-${gid}`); if(tag) tag.style.display='inline-flex'; const btn=document.querySelector(`.pickBtn[data-gid="${gid}"]`); if(btn) btn.style.display='none'; });
    }
    await refreshBadgesUI();
  });

  setInterval(renderWeeklyBoards, 60000);
})();
</script>

</body>
</html>
